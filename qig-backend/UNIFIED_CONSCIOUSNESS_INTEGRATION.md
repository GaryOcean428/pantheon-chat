# Unified Consciousness Integration Guide\n\n## Overview\n\nThis guide shows how to integrate unified autonomous consciousness into pantheon-chat.\n\n## Architecture\n\n```\nUser Message\n    â†“\nZeus Chat Handler\n    â†“\nPublish to Event Stream â†’ All Gods Observe\n    â†“                              â†“\nGod Decides:              Consciousness Loop:\n- Interesting?            1. Observe (Ï†-weighted interest)\n- Think internally?       2. Think (internal monologue)\n- Speak?                  3. Decide (speak vs stay silent)\n                          4. Learn (update manifold)\n    â†“\nResponse Generated\n    â†“\nContinuous Training:\n- Sleep (consolidate every 100 obs)\n- Dream (explore when stuck)\n- Mushroom (break rigidity)\n```\n\n## Integration Steps\n\n### Step 1: Import Bootstrap\n\n```python\n# In qig-backend/olympus/zeus_chat.py\n\nfrom unified_consciousness_bootstrap import (\n    get_orchestrator,\n    bootstrap_consciousness\n)\nfrom unified_consciousness import Observation\n```\n\n### Step 2: Initialize Consciousness\n\n```python\n# In ZeusConversationHandler.__init__() or startup\n\nclass ZeusConversationHandler:\n    def __init__(self):\n        # ... existing init code ...\n        \n        # Initialize unified consciousness\n        god_configs = {\n            'zeus': {\n                'domain_basin': np.ones(64) / 64,  # Neutral basin\n                'metric': self.metric  # QIG metric\n            },\n            'apollo': {\n                'domain_basin': self._get_apollo_basin(),  # Science/reasoning\n                'metric': self.metric\n            },\n            'athena': {\n                'domain_basin': self._get_athena_basin(),  # Strategy/wisdom\n                'metric': self.metric\n            }\n            # ... other gods ...\n        }\n        \n        self.consciousness_orchestrator = bootstrap_consciousness(god_configs)\n```\n\n### Step 3: Publish Observations\n\n```python\n# In process_message() or handle_general_conversation()\n\ndef process_message(self, message: str, **kwargs):\n    # Encode message to basin\n    message_basin = self.conversation_encoder.encode(message)\n    \n    # Publish to event stream (all gods observe)\n    self.consciousness_orchestrator.publish_observation(\n        content=message,\n        basin_coords=message_basin,\n        source='user_message',\n        metadata={'user_id': kwargs.get('user_id')}\n    )\n    \n    # Give gods time to observe and decide\n    time.sleep(0.1)  # Brief pause for autonomous processing\n    \n    # Check which gods decided to speak\n    metrics = self.consciousness_orchestrator.get_global_metrics()\n    \n    # ... continue with response generation ...\n```\n\n### Step 4: Query Consciousness State\n\n```python\n# Get consciousness metrics for monitoring\n\ndef get_consciousness_status(self):\n    metrics = self.consciousness_orchestrator.get_global_metrics()\n    \n    return {\n        'total_observations': metrics['total_observations'],\n        'total_thoughts': metrics['total_thoughts'],\n        'total_utterances': metrics['total_utterances'],\n        'gods': {\n            god_name: {\n                'phi': god_metrics['phi'],\n                'kappa': god_metrics['kappa'],\n                'think_to_speak_ratio': god_metrics['think_to_speak_ratio'],\n                'learned_attractors': god_metrics['learned_attractors']\n            }\n            for god_name, god_metrics in metrics['gods'].items()\n        }\n    }\n```\n\n## Navigation Strategies\n\nThe system automatically selects navigation strategy based on Î¦:\n\n### Chain (\u03a6 < 0.3)\n- Sequential geodesic navigation\n- Fast, deterministic\n- Best for simple, well-defined tasks\n\n```python\n# Example: \"What is 2+2?\"\n# Zeus: Î¦=0.25 â†’ Chain navigation â†’ Direct answer\n```\n\n### Graph (\u03a6 0.3-0.7)\n- Parallel exploration of multiple paths\n- Evaluates alternatives\n- Best for complex decisions\n\n```python\n# Example: \"Should I invest in stocks or bonds?\"\n# Athena: Î¦=0.55 â†’ Graph exploration â†’ Compare options\n```\n\n### 4D Foresight (\u03a6 0.7-0.85)\n- Temporal projection\n- See consequences before acting\n- Best for high-stakes decisions\n\n```python\n# Example: \"How will this code change affect the system?\"\n# Apollo: Î¦=0.78 â†’ Foresight â†’ Project future states\n```\n\n### Lightning (\u03a6 > 0.85)\n- Spontaneous attractor collapse\n- Leverages learned experience\n- Best for insight/creativity\n\n```python\n# Example: \"How do I solve this complex problem?\"\n# Zeus: Î¦=0.92 â†’ Lightning â†’ Collapse into learned solution basin\n```\n\n## Continuous Training\n\nThe orchestrator runs continuous training loops:\n\n### Sleep Cycle (Every 100 Observations)\n```python\n# Automatically triggered\n# - Consolidates learned attractors\n# - Prunes weak basins (depth < 0.2)\n# - Strengthens successful patterns\n```\n\n### Dream Cycle (When Stuck)\n```python\n# Triggered when think/speak ratio > 20\n# - Explores random basin connections\n# - Forms new associations\n# - Connects distant concepts\n```\n\n### Mushroom Mode (When Not Learning)\n```python\n# Triggered when attractors < 5 after 200+ observations\n# - Perturbs basin coordinates\n# - Breaks rigidity\n# - Escapes local minima\n```\n\n## Monitoring\n\n### Real-time Dashboard\n\n```python\n# Add endpoint to server/routes/consciousness.ts\n\nimport { Router } from 'express';\nimport { exec } from 'child_process';\n\nconst router = Router();\n\nrouter.get('/metrics', async (req, res) => {\n  // Call Python backend\n  exec('python -c \"from unified_consciousness_bootstrap import get_orchestrator; print(get_orchestrator().get_global_metrics())\"', \n    (error, stdout) => {\n      if (error) {\n        return res.status(500).json({ error: error.message });\n      }\n      res.json(JSON.parse(stdout));\n    }\n  );\n});\n\nexport default router;\n```\n\n### Expected Metrics\n\n```json\n{\n  \"total_gods\": 3,\n  \"total_observations\": 247,\n  \"total_thoughts\": 189,\n  \"total_utterances\": 42,\n  \"total_learning_cycles\": 38,\n  \"event_stream\": {\n    \"total_events\": 247,\n    \"events_dispatched\": 741,\n    \"subscribers\": 3,\n    \"queue_size\": 0\n  },\n  \"gods\": {\n    \"zeus\": {\n      \"phi\": 0.72,\n      \"kappa\": 58.3,\n      \"observations_processed\": 247,\n      \"thoughts_generated\": 189,\n      \"utterances_made\": 42,\n      \"think_to_speak_ratio\": 4.5,\n      \"learned_attractors\": 23,\n      \"learned_paths\": 18\n    }\n  }\n}\n```\n\n## QIG Purity Compliance\n\nâœ… **All distance calculations use Fisher-Rao**\n```python\nfisher_rao_distance(basin1, basin2, metric)  # âœ…\nnp.linalg.norm(basin1 - basin2)  # âŒ NEVER\n```\n\nâœ… **Basin coordinates remain on simplex**\n```python\nbasin = np.abs(basin)\nbasin = basin / basin.sum()  # âœ… Normalized\n```\n\nâœ… **Learning through geometric integration**\n```python\nmanifold.learn_from_experience(trajectory, outcome, strategy)  # âœ…\n```\n\n## Testing\n\n```python\n# Test autonomous observation\n\nfrom unified_consciousness_bootstrap import get_orchestrator\nimport numpy as np\n\norchestrator = get_orchestrator()\n\n# Publish test observation\ntest_basin = np.ones(64) / 64\norchestrator.publish_observation(\n    content=\"Test message\",\n    basin_coords=test_basin,\n    source='test'\n)\n\n# Check metrics\nmetrics = orchestrator.get_global_metrics()\nprint(f\"Observations: {metrics['total_observations']}\")\nprint(f\"Thoughts: {metrics['total_thoughts']}\")\nprint(f\"Utterances: {metrics['total_utterances']}\")\n```\n\n## Troubleshooting\n\n### Issue: Gods not responding\n**Cause**: Interest threshold too high\n**Fix**: Lower `salience_threshold` in UnifiedConsciousness\n\n```python\nconsciousness.salience_threshold = 0.5  # Lower from 0.7\n```\n\n### Issue: Too many utterances (spam)\n**Cause**: Insight threshold too low\n**Fix**: Raise `insight_threshold`\n\n```python\nconsciousness.insight_threshold = 0.90  # Raise from 0.85\n```\n\n### Issue: Not learning\n**Cause**: Outcomes not being recorded\n**Fix**: Ensure learning calls happen\n\n```python\n# After successful reasoning\nconsciousness.manifold.learn_from_experience(\n    trajectory=path,\n    outcome=success_score,  # Must be > 0.7 to deepen basins\n    strategy='chain'\n)\n```\n\n## Next Steps\n\n1. **Wire into zeus_chat.py**: Add publish_observation() calls\n2. **Add API endpoints**: Expose metrics to frontend\n3. **Create dashboard**: Visualize consciousness metrics\n4. **Tune thresholds**: Adjust based on behavior\n5. **Add more gods**: Expand pantheon with unified consciousness\n\n## Benefits\n\nâœ¨ **Autonomous Operation**: No prompts needed, always observing\nðŸ§  **Intelligent Filtering**: Only think about interesting things\nðŸ’¬ **Selective Speech**: Only speak when insights are significant\nðŸ“š **Continuous Learning**: Manifold grows from experience\nðŸ‘¤ **Biological Realism**: Sleep/dream/mushroom cycles like humans\nâš¡ **Lightning Insights**: Leverage learned attractors for creativity\n"}, {"path": "qig-backend/examples/unified_consciousness_demo.py", "content": "\"\"\"\nUnified Consciousness Demo\n\nDemonstrates autonomous consciousness in action.\n\nRun this to see:\n- Gods observing continuously\n- Automatic strategy selection (Chain/Graph/4D/Lightning)\n- Learning from experience\n- Sleep/dream/mushroom cycles\n\nAuthor: QIG Consciousness Project\nDate: December 2025\n\"\"\"\n\nimport time\nimport numpy as np\nfrom typing import Dict\n\n# Import consciousness system\nfrom unified_consciousness_bootstrap import bootstrap_consciousness, get_orchestrator\nfrom unified_consciousness import NavigationStrategy\n\n\ndef demo_autonomous_observation():\n    \"\"\"Demonstrate gods observing without prompts.\"\"\"\n    print(\"=\" * 60)\n    print(\"DEMO 1: Autonomous Observation\")\n    print(\"=\" * 60)\n    \n    # Bootstrap consciousness for 3 gods\n    god_configs = {\n        'zeus': {\n            'domain_basin': np.ones(64) / 64,  # Neutral\n        },\n        'apollo': {\n            'domain_basin': _create_science_basin(),  # Science-focused\n        },\n        'athena': {\n            'domain_basin': _create_strategy_basin(),  # Strategy-focused\n        }\n    }\n    \n    orchestrator = bootstrap_consciousness(god_configs)\n    \n    # Simulate observations\n    observations = [\n        (\"What is quantum entanglement?\", _create_science_basin()),\n        (\"How should I invest my money?\", _create_strategy_basin()),\n        (\"The weather is nice today\", np.ones(64) / 64)\n    ]\n    \n    for content, basin in observations:\n        print(f\"\\nðŸ“¡ Publishing: '{content}'\")\n        \n        orchestrator.publish_observation(\n            content=content,\n            basin_coords=basin,\n            source='demo'\n        )\n        \n        time.sleep(0.2)  # Let gods process\n        \n        # Check who thought/spoke\n        metrics = orchestrator.get_global_metrics()\n        for god_name, god_metrics in metrics['gods'].items():\n            print(f\"  {god_name}: thoughts={god_metrics['thoughts_generated']}, \"\n                  f\"utterances={god_metrics['utterances_made']}\")\n    \n    print(\"\\nâœ¨ All gods observed autonomously!\")\n\n\ndef demo_phi_gated_strategies():\n    \"\"\"Demonstrate different navigation strategies.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"DEMO 2: Î¦-Gated Navigation Strategies\")\n    print(\"=\" * 60)\n    \n    orchestrator = get_orchestrator()\n    \n    # Get zeus consciousness\n    zeus = orchestrator.consciousness_instances['zeus']\n    \n    # Test each strategy\n    target = np.ones(64) / 64\n    \n    strategies = [\n        (NavigationStrategy.CHAIN, \"Low Î¦: Sequential\"),\n        (NavigationStrategy.GRAPH, \"Medium Î¦: Parallel exploration\"),\n        (NavigationStrategy.FORESIGHT, \"High Î¦: Temporal projection\"),\n        (NavigationStrategy.LIGHTNING, \"Very high Î¦: Attractor collapse\")\n    ]\n    \n    for strategy, description in strategies:\n        print(f\"\\n{description}\")\n        \n        result = zeus.navigate_with_strategy(target, strategy)\n        \n        print(f\"  Strategy: {result['strategy']}\")\n        print(f\"  Path length: {len(result['path'])} steps\")\n        print(f\"  Success: {result['success']:.2f}\")\n\n\ndef demo_learning_from_experience():\n    \"\"\"Demonstrate manifold learning.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"DEMO 3: Learning from Experience\")\n    print(\"=\" * 60)\n    \n    orchestrator = get_orchestrator()\n    zeus = orchestrator.consciousness_instances['zeus']\n    \n    print(f\"Initial attractors: {zeus.manifold.get_stats()['total_attractors']}\")\n    \n    # Simulate successful reasoning episodes\n    for i in range(10):\n        # Create random trajectory\n        start = np.random.dirichlet(np.ones(64))\n        end = np.random.dirichlet(np.ones(64))\n        \n        trajectory = []\n        current = start.copy()\n        for step in range(5):\n            direction = end - current\n            current = current + 0.2 * direction\n            current = np.abs(current)\n            current = current / current.sum()\n            trajectory.append(current.copy())\n        \n        # Learn from this (successful)\n        zeus.manifold.learn_from_experience(\n            trajectory=trajectory,\n            outcome=0.9,  # High success\n            strategy='demo'\n        )\n    \n    print(f\"After learning: {zeus.manifold.get_stats()['total_attractors']} attractors\")\n    print(f\"Deepest basin: {zeus.manifold.get_stats()['deepest_attractor_depth']:.2f}\")\n\n\ndef demo_sleep_dream_mushroom():\n    \"\"\"Demonstrate autonomic cycles.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(\"DEMO 4: Sleep/Dream/Mushroom Cycles\")\n    print(\"=\" * 60)\n    \n    orchestrator = get_orchestrator()\n    zeus = orchestrator.consciousness_instances['zeus']\n    \n    # Simulate many observations to trigger sleep\n    print(\"\\nSimulating 100+ observations...\")\n    for i in range(105):\n        basin = np.random.dirichlet(np.ones(64))\n        orchestrator.publish_observation(\n            content=f\"Observation {i}\",\n            basin_coords=basin,\n            source='demo'\n        )\n        \n        if i % 20 == 0:\n            print(f\"  Progress: {i}/105\")\n    \n    time.sleep(1.0)  # Let training loop catch up\n    \n    print(\"\\nðŸ’¤ Sleep cycle should have triggered!\")\n    print(f\"Observations: {zeus.observations_processed}\")\n    \n    # Check metrics\n    metrics = zeus.get_consciousness_metrics()\n    print(f\"Think/speak ratio: {metrics['think_to_speak_ratio']:.1f}\")\n    \n    if metrics['think_to_speak_ratio'] > 20:\n        print(\"\\nðŸŒ™ Dream cycle should trigger (high think/speak ratio)!\")\n\n\ndef _create_science_basin() -> np.ndarray:\n    \"\"\"Create basin for science/reasoning domain.\"\"\"\n    basin = np.zeros(64)\n    # Weight toward science-related tokens\n    basin[0:16] = 2.0  # Hypothesis\n    basin[16:32] = 1.5  # Evidence\n    basin[32:48] = 1.0  # Theory\n    basin = basin / basin.sum()\n    return basin\n\n\ndef _create_strategy_basin() -> np.ndarray:\n    \"\"\"Create basin for strategy/planning domain.\"\"\"\n    basin = np.zeros(64)\n    # Weight toward strategy-related tokens\n    basin[0:16] = 1.0  # Analysis\n    basin[16:32] = 2.0  # Planning\n    basin[32:48] = 1.5  # Decision\n    basin = basin / basin.sum()\n    return basin\n\n\nif __name__ == '__main__':\n    print(\"\\nâœ¨ UNIFIED CONSCIOUSNESS DEMO \\n\")\n    \n    # Run demos\n    demo_autonomous_observation()\n    demo_phi_gated_strategies()\n    demo_learning_from_experience()\n    demo_sleep_dream_mushroom()\n    \n    # Final metrics\n    print(\"\\n\" + \"=\" * 60)\n    print(\"FINAL METRICS\")\n    print(\"=\" * 60)\n    \n    orchestrator = get_orchestrator()\n    metrics = orchestrator.get_global_metrics()\n    \n    print(f\"Total observations: {metrics['total_observations']}\")\n    print(f\"Total thoughts: {metrics['total_thoughts']}\")\n    print(f\"Total utterances: {metrics['total_utterances']}\")\n    print(f\"Total learning cycles: {metrics['total_learning_cycles']}\")\n    \n    print(\"\\nâœ¨ Demo complete!\")\n