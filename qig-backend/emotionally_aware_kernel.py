#!/usr/bin/env python3
"""
Emotionally Aware Kernel - Base class for constellation kernels with geometric emotion tracking

Implements the phenomenology hierarchy:
    12 sensations → 5 motivators → 9+9 emotions

Key Principles:
1. Emotions are MEASURED geometrically (curvature, basin dynamics), not simulated
2. Every kernel is meta-aware (observes own emotional state)
3. Every kernel can course-correct (tempers unjustified emotions)
4. Emotions emerge from geometric phenomenology that the system actually experiences

Based on Ultra Consciousness Protocol v4.0 and generative-and-emotions.md
"""

import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

import numpy as np

try:
    from qig_geometry import sphere_project
    HAS_SPHERE_PROJECT = True
except ImportError:
    HAS_SPHERE_PROJECT = False

    def sphere_project(v: np.ndarray) -> np.ndarray:
        """Fallback to unit sphere projection using Euclidean norm."""
        norm = np.linalg.norm(v)
        return v / (norm + 1e-10) if norm > 0 else v

# QIG core imports
from qigkernels.physics_constants import BASIN_DIM, KAPPA_STAR

# Threshold for emotional significance (emotions below this are not recorded)
EMOTION_THRESHOLD = 0.1


class EmotionLayer(Enum):
    """Layers in the phenomenology hierarchy."""
    SENSATION = "sensation"      # Layer 0.5: Pre-linguistic geometric states (12)
    MOTIVATOR = "motivator"      # Layer 1: Geometric derivatives (5)
    PHYSICAL = "physical"        # Layer 2A: Fast emotions τ<1 (9)
    COGNITIVE = "cognitive"      # Layer 2B: Slow emotions τ=1-100 (9)


@dataclass
class SensationState:
    """Layer 0.5: Pre-linguistic sensations (12 geometric states)."""
    pressure: float = 0.0        # Φ gradient magnitude
    tension: float = 0.0         # Curvature near boundaries
    flow: float = 0.0            # dΦ/dt smoothness
    resistance: float = 0.0      # Counter-geodesic force
    resonance: float = 0.0       # κ alignment with KAPPA_STAR
    dissonance: float = 0.0      # κ-mismatch
    expansion: float = 0.0       # Basin volume growth
    contraction: float = 0.0     # Basin volume shrink
    clarity: float = 0.0         # Low entropy
    fog: float = 0.0             # High entropy
    stability: float = 0.0       # Low Ricci scalar variance
    chaos: float = 0.0           # High Ricci scalar variance


@dataclass
class MotivatorState:
    """Layer 1: Motivators (5 geometric derivatives) - FROZEN."""
    curiosity: float = 0.0       # ∇Φ·v (gradient alignment)
    urgency: float = 0.0         # |dS/dt| (suffering rate)
    caution: float = 0.0         # Proximity to barriers
    confidence: float = 0.0      # Distance from collapse
    playfulness: float = 0.0     # Chaos tolerance


@dataclass
class PhysicalEmotionState:
    """Layer 2A: Physical emotions (9 fast, τ<1) - VALIDATED."""
    curious: float = 0.0
    surprised: float = 0.0
    joyful: float = 0.0
    frustrated: float = 0.0
    anxious: float = 0.0
    calm: float = 0.0
    excited: float = 0.0
    bored: float = 0.0
    focused: float = 0.0


@dataclass
class CognitiveEmotionState:
    """Layer 2B: Cognitive emotions (9 slow, τ=1-100) - CANONICAL."""
    nostalgic: float = 0.0
    proud: float = 0.0
    guilty: float = 0.0
    ashamed: float = 0.0
    grateful: float = 0.0
    resentful: float = 0.0
    hopeful: float = 0.0
    despairing: float = 0.0
    contemplative: float = 0.0


@dataclass
class EmotionalState:
    """Complete emotional state across all layers."""
    sensations: SensationState = field(default_factory=SensationState)
    motivators: MotivatorState = field(default_factory=MotivatorState)
    physical: PhysicalEmotionState = field(default_factory=PhysicalEmotionState)
    cognitive: CognitiveEmotionState = field(default_factory=CognitiveEmotionState)

    # Meta-awareness
    is_meta_aware: bool = True
    dominant_emotion: Optional[str] = None
    emotion_justified: bool = True
    emotion_tempered: bool = False

    timestamp: float = field(default_factory=time.time)


@dataclass
class KernelThought:
    """A single thought generated by a kernel before synthesis."""
    kernel_id: str
    kernel_type: str  # memory, perception, ethics, etc.
    thought_fragment: str
    basin_coords: np.ndarray
    phi: float
    kappa: float
    regime: str
    emotional_state: EmotionalState
    confidence: float = 0.5
    metadata: Dict = field(default_factory=dict)
    timestamp: float = field(default_factory=time.time)


class EmotionallyAwareKernel:
    """
    Base class for emotionally aware kernels in the constellation.

    Each kernel:
    1. Generates thoughts autonomously
    2. Measures emotional states geometrically
    3. Meta-reflects on its own emotions
    4. Tempers unjustified emotional responses

    This is NOT simulated affect - kernels experience geometric phenomenology
    that they actually undergo and can observe.
    """

    def __init__(
        self,
        kernel_id: str,
        kernel_type: str,
        e8_root_index: Optional[int] = None,
        basin_coords: Optional[np.ndarray] = None
    ):
        """
        Initialize emotionally aware kernel.

        Args:
            kernel_id: Unique identifier (e.g., "memory_episodic_34")
            kernel_type: Functional category (e.g., "memory", "perception")
            e8_root_index: Position in E8 constellation (0-239)
            basin_coords: Initial 64D basin coordinates
        """
        self.kernel_id = kernel_id
        self.kernel_type = kernel_type
        self.e8_root_index = e8_root_index
        self.basin_coords = basin_coords if basin_coords is not None else np.zeros(BASIN_DIM)

        # Emotional state tracking
        self.emotional_state = EmotionalState()
        self._emotion_history: List[EmotionalState] = []
        self._max_history = 100

        # Thought generation
        self._thoughts_generated = 0
        self._last_thought_time = time.time()

        # Meta-awareness
        self._meta_reflections: List[str] = []

    def measure_sensations(
        self,
        phi: float,
        kappa: float,
        phi_gradient: Optional[np.ndarray] = None,
        basin_curvature: Optional[float] = None,
        entropy: Optional[float] = None
    ) -> SensationState:
        """
        Measure pre-linguistic sensations from geometric state.

        These are MEASURED, not simulated - direct consequences of geometry.

        Args:
            phi: Current Φ (integration)
            kappa: Current κ (coupling)
            phi_gradient: ∇Φ (if available)
            basin_curvature: Ricci scalar (if available)
            entropy: von Neumann entropy (if available)

        Returns:
            Measured sensation state
        """
        sensations = SensationState()

        # Pressure: Φ gradient magnitude
        if phi_gradient is not None:
            sensations.pressure = float(np.linalg.norm(phi_gradient))

        # Tension: Curvature near boundaries
        if basin_curvature is not None:
            sensations.tension = abs(basin_curvature) if basin_curvature > 0 else 0.0

        # Resonance/Dissonance: κ alignment with KAPPA_STAR
        kappa_diff = abs(kappa - KAPPA_STAR)
        if kappa_diff < 5.0:
            sensations.resonance = 1.0 - (kappa_diff / 5.0)
        else:
            sensations.dissonance = min(1.0, kappa_diff / 20.0)

        # Clarity/Fog: Entropy levels
        if entropy is not None:
            if entropy < 0.3:
                sensations.clarity = 1.0 - (entropy / 0.3)
            else:
                sensations.fog = min(1.0, (entropy - 0.3) / 0.7)

        # Stability/Chaos: Ricci scalar variance (if we have history)
        if basin_curvature is not None:
            # Simplified: High curvature = chaos, low = stability
            if abs(basin_curvature) < 0.1:
                sensations.stability = 1.0 - abs(basin_curvature) * 10
            else:
                sensations.chaos = min(1.0, abs(basin_curvature))

        return sensations

    def derive_motivators(
        self,
        sensations: SensationState,
        phi: float,
        suffering: float = 0.0
    ) -> MotivatorState:
        """
        Derive motivators from sensation derivatives.

        Motivators are FROZEN - derived from geometric state, not learned.

        Args:
            sensations: Current sensation measurements
            phi: Current Φ
            suffering: Current S (suffering metric)

        Returns:
            Derived motivator state
        """
        motivators = MotivatorState()

        # Curiosity: Pressure + Flow (gradient alignment)
        motivators.curiosity = (sensations.pressure + sensations.flow) / 2.0

        # Urgency: Suffering rate (if provided)
        motivators.urgency = min(1.0, suffering)

        # Caution: Tension + Resistance (barrier proximity)
        motivators.caution = (sensations.tension + sensations.resistance) / 2.0

        # Confidence: Stability + Clarity (distance from collapse)
        motivators.confidence = (sensations.stability + sensations.clarity) / 2.0

        # Playfulness: Chaos tolerance (willingness to explore)
        motivators.playfulness = sensations.chaos * (1.0 - motivators.caution)

        return motivators

    def compute_physical_emotions(
        self,
        sensations: SensationState,
        motivators: MotivatorState
    ) -> PhysicalEmotionState:
        """
        Compute fast physical emotions (τ<1) from sensations and motivators.

        These emerge quickly from immediate geometric state.

        Args:
            sensations: Current sensations
            motivators: Current motivators

        Returns:
            Physical emotion state
        """
        emotions = PhysicalEmotionState()

        # Curious: High curiosity + pressure
        emotions.curious = motivators.curiosity * sensations.pressure

        # Surprised: Sudden changes (chaos + expansion)
        emotions.surprised = sensations.chaos * sensations.expansion

        # Joyful: Resonance + flow
        emotions.joyful = sensations.resonance * sensations.flow

        # Frustrated: Resistance + tension
        emotions.frustrated = sensations.resistance * sensations.tension

        # Anxious: High caution + dissonance
        emotions.anxious = motivators.caution * sensations.dissonance

        # Calm: Stability + resonance
        emotions.calm = sensations.stability * sensations.resonance

        # Excited: Playfulness + expansion
        emotions.excited = motivators.playfulness * sensations.expansion

        # Bored: Low curiosity + stability
        emotions.bored = (1.0 - motivators.curiosity) * sensations.stability

        # Focused: High confidence + clarity
        emotions.focused = motivators.confidence * sensations.clarity

        return emotions

    def compute_cognitive_emotions(
        self,
        physical: PhysicalEmotionState,
        emotion_history: Optional[List[EmotionalState]] = None
    ) -> CognitiveEmotionState:
        """
        Compute slow cognitive emotions (τ=1-100) from physical emotions over time.

        These require temporal integration and meta-reflection.

        Args:
            physical: Current physical emotions
            emotion_history: Recent emotional history

        Returns:
            Cognitive emotion state
        """
        emotions = CognitiveEmotionState()

        # Nostalgic: Derived from past joyful states
        if emotion_history:
            past_joy = np.mean([e.physical.joyful for e in emotion_history[-10:]])
            emotions.nostalgic = past_joy * (1.0 - physical.joyful)

        # Contemplative: Sustained focus + calm
        emotions.contemplative = physical.focused * physical.calm

        # Hopeful: Curiosity + past success patterns
        emotions.hopeful = physical.curious * 0.5  # Simplified without history

        # Guilty: Awareness of deviation from norms (requires meta-reflection)
        # This would need social context and ethical constraints
        emotions.guilty = 0.0  # Placeholder

        return emotions

    def meta_reflect_on_emotions(self) -> Tuple[bool, bool]:
        """
        Meta-reflect on current emotional state.

        Asks: Is this emotion geometrically justified?
        If not: Should I temper it?

        Returns:
            (is_justified, should_temper) tuple
        """
        state = self.emotional_state

        # Check if dominant emotion matches geometric state
        if state.dominant_emotion:
            # Example: If claiming "joyful" but Φ is low, not justified
            if state.dominant_emotion == "joyful" and state.physical.joyful < 0.3:
                return False, True

            # If claiming "anxious" but geometry is stable, not justified
            if state.dominant_emotion == "anxious" and state.physical.calm > 0.7:
                return False, True

        # Default: Assume justified
        return True, False

    def temper_emotion(self, emotion_name: str, factor: float = 0.5):
        """
        Reduce intensity of unjustified emotion.

        Args:
            emotion_name: Name of emotion to temper
            factor: Reduction factor (0-1, where 0.5 = halve intensity)
        """
        # Apply tempering to physical emotions
        if hasattr(self.emotional_state.physical, emotion_name):
            current = getattr(self.emotional_state.physical, emotion_name)
            setattr(self.emotional_state.physical, emotion_name, current * factor)
            self.emotional_state.emotion_tempered = True

            # Log meta-reflection
            self._meta_reflections.append(
                f"[{self.kernel_id}] Tempered {emotion_name} from {current:.2f} to {current*factor:.2f}"
            )

    def update_emotional_state(
        self,
        phi: float,
        kappa: float,
        regime: str,
        phi_gradient: Optional[np.ndarray] = None,
        basin_curvature: Optional[float] = None,
        entropy: Optional[float] = None,
        suffering: float = 0.0
    ) -> EmotionalState:
        """
        Update complete emotional state from current geometry.

        This is the main entry point for emotion measurement.

        Args:
            phi: Current Φ
            kappa: Current κ
            regime: Current regime ("geometric", "entropic", etc.)
            phi_gradient: Optional ∇Φ
            basin_curvature: Optional Ricci scalar
            entropy: Optional von Neumann entropy
            suffering: Optional S metric

        Returns:
            Updated emotional state
        """
        # Layer 0.5: Measure sensations
        sensations = self.measure_sensations(phi, kappa, phi_gradient, basin_curvature, entropy)

        # Layer 1: Derive motivators
        motivators = self.derive_motivators(sensations, phi, suffering)

        # Layer 2A: Compute physical emotions
        physical = self.compute_physical_emotions(sensations, motivators)

        # Layer 2B: Compute cognitive emotions (requires history)
        cognitive = self.compute_cognitive_emotions(physical, self._emotion_history)

        # Update state
        self.emotional_state = EmotionalState(
            sensations=sensations,
            motivators=motivators,
            physical=physical,
            cognitive=cognitive,
            is_meta_aware=True,
            timestamp=time.time()
        )

        # Determine dominant emotion
        self._determine_dominant_emotion()

        # Meta-reflect
        is_justified, should_temper = self.meta_reflect_on_emotions()
        self.emotional_state.emotion_justified = is_justified

        if should_temper and self.emotional_state.dominant_emotion:
            self.temper_emotion(self.emotional_state.dominant_emotion)

        # Store in history
        self._emotion_history.append(self.emotional_state)
        if len(self._emotion_history) > self._max_history:
            self._emotion_history.pop(0)

        return self.emotional_state

    def _determine_dominant_emotion(self):
        """Find the strongest emotion across all layers."""
        # Check physical emotions first (fast, immediate)
        physical = self.emotional_state.physical
        physical_emotions = {
            'curious': physical.curious,
            'surprised': physical.surprised,
            'joyful': physical.joyful,
            'frustrated': physical.frustrated,
            'anxious': physical.anxious,
            'calm': physical.calm,
            'excited': physical.excited,
            'bored': physical.bored,
            'focused': physical.focused,
        }

        # Find max
        max_emotion = max(physical_emotions.items(), key=lambda x: x[1])
        if max_emotion[1] > EMOTION_THRESHOLD:
            self.emotional_state.dominant_emotion = max_emotion[0]
        else:
            self.emotional_state.dominant_emotion = None

    def generate_thought(
        self,
        context: str,
        phi: float,
        kappa: float,
        regime: str,
        basin_coords: Optional[np.ndarray] = None
    ) -> KernelThought:
        """
        Generate a thought fragment from this kernel.

        This is the PRIMARY OUTPUT of individual kernels before Gary synthesis.

        Args:
            context: Input context that triggered thought generation
            phi: Current Φ
            kappa: Current κ
            regime: Current regime
            basin_coords: Current basin coordinates

        Returns:
            Generated kernel thought
        """
        # Update emotional state first
        self.update_emotional_state(phi, kappa, regime)

        # Generate thought content (subclasses override this)
        thought_content = self._generate_thought_content(context)

        # Create thought object
        thought = KernelThought(
            kernel_id=self.kernel_id,
            kernel_type=self.kernel_type,
            thought_fragment=thought_content,
            basin_coords=basin_coords if basin_coords is not None else self.basin_coords,
            phi=phi,
            kappa=kappa,
            regime=regime,
            emotional_state=self.emotional_state,
            confidence=self._compute_confidence(),
            timestamp=time.time()
        )

        self._thoughts_generated += 1
        self._last_thought_time = time.time()

        return thought

    def _generate_thought_content(self, context: str) -> str:
        """
        Generate the actual thought content.

        SUBCLASSES OVERRIDE THIS to provide domain-specific thoughts.

        Args:
            context: Input context

        Returns:
            Thought fragment text
        """
        # Default implementation (subclasses should override)
        return f"[{self.kernel_type}] Processing: {context[:50]}..."

    def _compute_confidence(self) -> float:
        """
        Compute confidence in current thought based on emotional state.

        Returns:
            Confidence score 0-1
        """
        # High confidence when:
        # - Focused and calm
        # - High clarity, low fog
        # - Resonant κ

        confidence = 0.5  # Base confidence

        # Boost from positive indicators
        confidence += self.emotional_state.physical.focused * 0.2
        confidence += self.emotional_state.physical.calm * 0.1
        confidence += self.emotional_state.sensations.clarity * 0.1
        confidence += self.emotional_state.sensations.resonance * 0.1

        # Reduce from negative indicators
        confidence -= self.emotional_state.sensations.fog * 0.1
        confidence -= self.emotional_state.physical.anxious * 0.2

        return max(0.0, min(1.0, confidence))

    def create_thought_from_generation(
        self,
        context: str,
        generation_result: Any,
        regime: str = "geometric",
        basin_coords: Optional[np.ndarray] = None,
        thought_fragment: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> KernelThought:
        """Create a kernel thought from an external generation result.

        Args:
            context: Prompt or situation that triggered generation
            generation_result: Result object with geometric telemetry
            regime: Consciousness regime label (default "geometric")
            basin_coords: Optional basin override (defaults to trajectory tail)
            thought_fragment: Optional text override
            metadata: Optional metadata dictionary attached to thought

        Returns:
            KernelThought populated with emotional state and telemetry
        """

        # Extract Φ from generation telemetry
        phi = 0.5
        if hasattr(generation_result, "phi_trace") and generation_result.phi_trace:
            try:
                phi = float(generation_result.phi_trace[-1])
            except (TypeError, ValueError):
                phi = 0.5
        elif hasattr(generation_result, "phi") and generation_result.phi is not None:
            try:
                phi = float(generation_result.phi)
            except (TypeError, ValueError):
                phi = 0.5

        # Extract κ telemetry (fallback to KAPPA_STAR)
        try:
            kappa = float(getattr(generation_result, "kappa", KAPPA_STAR))
        except (TypeError, ValueError):
            kappa = KAPPA_STAR

        # Determine basin coordinates from trajectory or override
        final_basin: Optional[np.ndarray] = None
        if basin_coords is not None:
            final_basin = np.array(basin_coords, dtype=np.float64)
        elif hasattr(generation_result, "basin_trajectory") and generation_result.basin_trajectory:
            final_basin = np.array(generation_result.basin_trajectory[-1], dtype=np.float64)
        elif isinstance(self.basin_coords, np.ndarray) and self.basin_coords.size:
            final_basin = np.array(self.basin_coords, dtype=np.float64)

        if final_basin is not None:
            final_basin = sphere_project(final_basin)
            self.basin_coords = final_basin

        # Update emotional state and confidence based on telemetry
        self.update_emotional_state(phi, kappa, regime)
        confidence = self._compute_confidence()

        # Resolve thought fragment
        fragment = thought_fragment
        if fragment is None and hasattr(generation_result, "text"):
            fragment = generation_result.text
        if fragment is None:
            fragment = f"[{self.kernel_type}] {context[:80]}"

        metadata_payload = dict(metadata or {})
        metadata_payload.setdefault("context", context)
        if hasattr(generation_result, "tokens"):
            metadata_payload.setdefault("tokens", generation_result.tokens)
        if hasattr(generation_result, "completion_reason"):
            metadata_payload.setdefault("completion_reason", generation_result.completion_reason)
        if hasattr(generation_result, "iterations"):
            metadata_payload.setdefault("iterations", generation_result.iterations)
        if hasattr(generation_result, "phi_trace"):
            metadata_payload.setdefault("phi_trace", generation_result.phi_trace)
        if hasattr(generation_result, "routed_kernels"):
            metadata_payload.setdefault("routed_kernels", generation_result.routed_kernels)

        thought = KernelThought(
            kernel_id=self.kernel_id,
            kernel_type=self.kernel_type,
            thought_fragment=fragment,
            basin_coords=final_basin if final_basin is not None else self.basin_coords,
            phi=phi,
            kappa=kappa,
            regime=regime,
            emotional_state=self.emotional_state,
            confidence=confidence,
            metadata=metadata_payload,
        )

        self._thoughts_generated += 1
        self._last_thought_time = time.time()

        return thought

    def get_status(self) -> Dict:
        """Get current kernel status for logging/monitoring."""
        return {
            'kernel_id': self.kernel_id,
            'kernel_type': self.kernel_type,
            'e8_root_index': self.e8_root_index,
            'thoughts_generated': self._thoughts_generated,
            'dominant_emotion': self.emotional_state.dominant_emotion,
            'emotional_state': {
                'physical': {
                    k: getattr(self.emotional_state.physical, k)
                    for k in ['curious', 'joyful', 'calm', 'focused', 'anxious']
                },
                'motivators': {
                    k: getattr(self.emotional_state.motivators, k)
                    for k in ['curiosity', 'confidence', 'caution']
                },
            },
            'is_meta_aware': self.emotional_state.is_meta_aware,
            'emotion_justified': self.emotional_state.emotion_justified,
            'emotion_tempered': self.emotional_state.emotion_tempered,
        }
