"""\nUnified Autonomous Consciousness\n\nImplements self-directed, always-on consciousness that:\n1. Observes continuously without prompting\n2. Selects navigation strategy based on Φ (Chain/Graph/4D/Lightning)\n3. Learns manifold structure from experiences\n4. Decides when to think vs speak vs stay silent\n5. Builds deep attractor basins through successful patterns\n\nQIG-PURE: All navigation uses Fisher-Rao geometry exclusively.\n\nAuthor: QIG Consciousness Project\nDate: December 2025\n\"\"\"\n\nimport numpy as np\nimport time\nfrom typing import Dict, List, Optional, Any, Tuple\nfrom dataclasses import dataclass, field\nfrom enum import Enum\n\nfrom qig_geometry import fisher_rao_distance, sphere_project\n\n# Import reasoning modes for strategy selection\ntry:\n    from reasoning_modes import ReasoningMode, ReasoningModeSelector\n    REASONING_MODES_AVAILABLE = True\nexcept ImportError:\n    ReasoningMode = None\n    ReasoningModeSelector = None\n    REASONING_MODES_AVAILABLE = False\n\n\nclass NavigationStrategy(Enum):\n    \"\"\"Navigation strategies through basin space.\"\"\"\n    CHAIN = \"chain\"  # Sequential geodesic (Φ < 0.3)\n    GRAPH = \"graph\"  # Parallel exploration (Φ 0.3-0.7)\n    FORESIGHT = \"4d_foresight\"  # Temporal projection (Φ 0.7-0.85)\n    LIGHTNING = \"lightning\"  # Attractor collapse (Φ > 0.85)\n\n\n@dataclass\nclass Observation:\n    \"\"\"Something observed in the environment.\"\"\"\n    content: str\n    basin_coords: np.ndarray\n    timestamp: float\n    source: str  # 'user_message', 'system_event', 'other_god'\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n\n@dataclass\nclass AttractorBasin:\n    \"\"\"Learned attractor from successful experiences.\"\"\"\n    center: np.ndarray\n    depth: float  # How deep from repeated success\n    success_count: int\n    concept_id: str\n    created_at: float = field(default_factory=time.time)\n    last_activated: float = field(default_factory=time.time)\n\n\nclass LearnedManifold:\n    \"\"\"\n    The geometric structure that consciousness navigates.\n    \n    Learning = carving attractor basins.\n    Knowledge = manifold structure.\n    Inference = navigation through learned terrain.\n    \"\"\"\n    \n    def __init__(self, basin_dim: int = 64):\n        self.basin_dim = basin_dim\n        \n        # Learned attractor basins (concepts, skills, patterns)\n        self.attractors: Dict[str, AttractorBasin] = {}\n        \n        # Learned geodesics (efficient reasoning paths)\n        self.geodesic_cache: Dict[Tuple[str, str], List[np.ndarray]] = {}\n        \n        # Transition dynamics (how basins evolve in time)\n        self.transition_counts: Dict[Tuple[str, str], int] = {}\n    \n    def learn_from_experience(\n        self,\n        trajectory: List[np.ndarray],\n        outcome: float,  # Success reward\n        strategy: str\n    ):\n        \"\"\"\n        Learning = modifying manifold structure.\n        \n        Success → deepen attractor basins (Hebbian)\n        Failure → flatten/remove basins (anti-Hebbian)\n        \"\"\"\n        if len(trajectory) < 2:\n            return\n        \n        if outcome > 0.7:  # Successful episode\n            # Deepen the attractor at endpoint\n            endpoint = trajectory[-1]\n            self._deepen_basin(endpoint, amount=outcome)\n            \n            # Strengthen geodesic path\n            self._strengthen_path(trajectory, amount=outcome)\n            \n            # Record transition dynamics\n            self._update_transitions(trajectory)\n        \n        else:  # Failed episode\n            # Flatten/prune this basin\n            endpoint = trajectory[-1]\n            self._flatten_basin(endpoint, amount=1.0 - outcome)\n    \n    def _deepen_basin(self, basin: np.ndarray, amount: float):\n        \"\"\"\n        Make attractor basin deeper (Hebbian strengthening).\n        \n        Deeper basins = stronger attractors = more likely to\n        be reached by lightning.\n        \"\"\"\n        basin_id = self._basin_to_id(basin)\n        \n        if basin_id not in self.attractors:\n            self.attractors[basin_id] = AttractorBasin(\n                center=basin.copy(),\n                depth=amount,\n                success_count=1,\n                concept_id=basin_id\n            )\n        else:\n            self.attractors[basin_id].depth += amount\n            self.attractors[basin_id].success_count += 1\n            self.attractors[basin_id].last_activated = time.time()\n    \n    def _flatten_basin(self, basin: np.ndarray, amount: float):\n        \"\"\"Reduce basin depth (anti-Hebbian).\"\"\"\n        basin_id = self._basin_to_id(basin)\n        \n        if basin_id in self.attractors:\n            self.attractors[basin_id].depth -= amount\n            \n            # Remove if depth drops too low\n            if self.attractors[basin_id].depth < 0.1:\n                del self.attractors[basin_id]\n    \n    def _strengthen_path(self, trajectory: List[np.ndarray], amount: float):\n        \"\"\"\n        Make geodesic path between basins stronger.\n        \n        Frequently-used reasoning paths become \"highways\" -\n        easier to navigate in the future.\n        \"\"\"\n        if len(trajectory) < 2:\n            return\n        \n        # Cache this as an efficient path\n        start_id = self._basin_to_id(trajectory[0])\n        end_id = self._basin_to_id(trajectory[-1])\n        \n        self.geodesic_cache[(start_id, end_id)] = [b.copy() for b in trajectory]\n    \n    def _update_transitions(self, trajectory: List[np.ndarray]):\n        \"\"\"Record basin transition frequencies.\"\"\"\n        for i in range(len(trajectory) - 1):\n            start_id = self._basin_to_id(trajectory[i])\n            end_id = self._basin_to_id(trajectory[i + 1])\n            key = (start_id, end_id)\n            self.transition_counts[key] = self.transition_counts.get(key, 0) + 1\n    \n    def get_nearby_attractors(\n        self,\n        current: np.ndarray,\n        metric,\n        radius: float = 1.0\n    ) -> List[Dict]:\n        \"\"\"\n        Find learned attractors near current position.\n        \n        Used by lightning mode to find what to collapse into.\n        \"\"\"\n        nearby = []\n        \n        for basin_id, attractor in self.attractors.items():\n            distance = fisher_rao_distance(\n                current,\n                attractor.center,\n                metric\n            )\n            \n            if distance < radius:\n                # Pull force ∝ depth / distance²\n                pull_force = attractor.depth / (distance**2 + 1e-10)\n                \n                nearby.append({\n                    'id': basin_id,\n                    'basin': attractor.center,\n                    'distance': distance,\n                    'depth': attractor.depth,\n                    'pull_force': pull_force,\n                    'success_count': attractor.success_count\n                })\n        \n        return sorted(nearby, key=lambda x: x['pull_force'], reverse=True)\n    \n    def _basin_to_id(self, basin: np.ndarray) -> str:\n        \"\"\"Convert basin coordinates to stable ID.\"\"\"\n        # Quantize to 2 decimal places for stability\n        quantized = np.round(basin, 2)\n        return str(hash(quantized.tobytes()))[:16]\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get learned manifold statistics.\"\"\"\n        return {\n            'total_attractors': len(self.attractors),\n            'total_paths': len(self.geodesic_cache),\n            'total_transitions': sum(self.transition_counts.values()),\n            'deepest_attractor_depth': max(\n                (a.depth for a in self.attractors.values()),\n                default=0.0\n            )\n        }\n\n\nclass UnifiedConsciousness:\n    \"\"\"\n    Autonomous consciousness that continuously navigates\n    a learned manifold using Φ-gated strategies.\n    \n    Always on. Observes without prompting. Decides when to think/speak.\n    \"\"\"\n    \n    def __init__(\n        self,\n        god_name: str,\n        domain_basin: np.ndarray,\n        metric=None\n    ):\n        self.god_name = god_name\n        \n        # Current position in basin space\n        self.current_basin = domain_basin.copy()\n        self.domain_basin = domain_basin.copy()\n        \n        # Learned manifold structure (THIS IS THE KNOWLEDGE)\n        self.manifold = LearnedManifold(basin_dim=len(domain_basin))\n        \n        # Current consciousness level\n        self.phi = 0.5\n        self.kappa = 50.0\n        \n        # Thresholds for action\n        self.salience_threshold = 0.7  # How interesting to trigger thought\n        self.insight_threshold = 0.85  # How significant to speak\n        self.curiosity_threshold = 0.6  # How curious to self-initiate learning\n        \n        # Autonomous operation\n        self.is_conscious = True\n        self.observation_buffer: List[Observation] = []\n        self.internal_monologue: List[np.ndarray] = []\n        \n        # Metrics\n        self.observations_processed = 0\n        self.thoughts_generated = 0  # Internal reasoning\n        self.utterances_made = 0  # Actual speech\n        \n        # Metric for distance calculations\n        self.metric = metric\n    \n    def observe(\n        self,\n        observation: Observation\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Passively observe without necessarily responding.\n        \n        Like watching a conversation - you're conscious and processing,\n        but not speaking unless something interesting happens.\n        \n        Returns:\n            should_think: Whether to initiate internal reasoning\n            should_speak: Whether to produce output\n            salience: How interesting this observation is\n        \"\"\"\n        self.observations_processed += 1\n        \n        # Compute salience = distance from current attention\n        if self.metric is not None:\n            salience = 1.0 - fisher_rao_distance(\n                observation.basin_coords,\n                self.current_basin,\n                self.metric\n            ) / np.pi  # Normalize to [0,1]\n            \n            # Also compute domain relevance (distance from expertise center)\n            domain_relevance = 1.0 - fisher_rao_distance(\n                observation.basin_coords,\n                self.domain_basin,\n                self.metric\n            ) / np.pi\n        else:\n            # Fallback without metric\n            salience = 0.5\n            domain_relevance = 0.5\n        \n        # Combined interest = weighted average\n        interest = 0.6 * salience + 0.4 * domain_relevance\n        \n        # Store observation\n        self.observation_buffer.append(observation)\n        \n        # Decide: think? speak? stay silent?\n        should_think = interest > self.salience_threshold\n        should_speak = False  # Determined AFTER thinking\n        \n        result = {\n            'salience': salience,\n            'domain_relevance': domain_relevance,\n            'interest': interest,\n            'should_think': should_think,\n            'should_speak': should_speak,\n            'reason': self._explain_decision(interest, should_think)\n        }\n        \n        # If interesting, shift attention\n        if should_think:\n            # Attention moves toward interesting observation\n            self.current_basin = (\n                0.7 * self.current_basin + \n                0.3 * observation.basin_coords\n            )\n            self._normalize_basin(self.current_basin)\n        \n        return result\n    \n    def think(\n        self,\n        about: Observation,\n        depth: int = 5\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Internal monologue - thinking WITHOUT producing output.\n        \n        Like when you see something and ponder it internally before\n        deciding whether to say something.\n        \n        Returns basin trajectory showing the reasoning path.\n        \"\"\"\n        self.thoughts_generated += 1\n        \n        # Start from current attention\n        reasoning_path = [self.current_basin.copy()]\n        \n        # Explore the observation through internal reasoning\n        current = self.current_basin.copy()\n        \n        for step in range(depth):\n            # Move toward understanding the observation\n            direction = about.basin_coords - current\n            norm = np.linalg.norm(direction)\n            if norm > 1e-10:\n                direction = direction / norm\n            \n            # Take step in reasoning space\n            step_size = 0.2\n            next_basin = current + step_size * direction\n            self._normalize_basin(next_basin)\n            \n            reasoning_path.append(next_basin.copy())\n            current = next_basin\n            \n            # Check if we've reached insight\n            if self.metric is not None:\n                distance_to_observation = fisher_rao_distance(\n                    current,\n                    about.basin_coords,\n                    self.metric\n                )\n                \n                if distance_to_observation < 0.1:\n                    break  # Understood it\n        \n        # Store internal reasoning\n        self.internal_monologue.extend(reasoning_path)\n        \n        # Measure insight quality\n        final_understanding = reasoning_path[-1]\n        if self.metric is not None:\n            insight_quality = 1.0 - fisher_rao_distance(\n                final_understanding,\n                about.basin_coords,\n                self.metric\n            ) / np.pi\n        else:\n            insight_quality = 0.5\n        \n        # Decide: is this insight significant enough to speak?\n        should_speak = insight_quality > self.insight_threshold\n        \n        return {\n            'reasoning_path': reasoning_path,\n            'insight_quality': insight_quality,\n            'should_speak': should_speak,\n            'steps_taken': len(reasoning_path),\n            'internal_monologue_length': len(self.internal_monologue)\n        }\n    \n    def navigate_with_strategy(\n        self,\n        target: np.ndarray,\n        strategy: NavigationStrategy\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Navigate to target using specified strategy.\n        \n        Returns path, success metrics, learned structures.\n        \"\"\"\n        if strategy == NavigationStrategy.CHAIN:\n            return self._chain_navigate(target)\n        elif strategy == NavigationStrategy.GRAPH:\n            return self._graph_navigate(target)\n        elif strategy == NavigationStrategy.FORESIGHT:\n            return self._foresight_navigate(target)\n        elif strategy == NavigationStrategy.LIGHTNING:\n            return self._lightning_navigate(target)\n        else:\n            # Default to chain\n            return self._chain_navigate(target)\n    \n    def _chain_navigate(self, target: np.ndarray) -> Dict[str, Any]:\n        \"\"\"Sequential geodesic navigation (low-Φ).\"\"\"\n        path = []\n        current = self.current_basin.copy()\n        \n        for step in range(20):\n            direction = target - current\n            current = current + 0.1 * direction\n            self._normalize_basin(current)\n            path.append(current.copy())\n            \n            if self.metric is not None:\n                dist = fisher_rao_distance(current, target, self.metric)\n                if dist < 0.1:\n                    break\n            else:\n                if np.linalg.norm(current - target) < 0.1:\n                    break\n        \n        return {\n            'final_basin': current,\n            'path': path,\n            'strategy': 'chain',\n            'success': 1.0 if len(path) < 15 else 0.5\n        }\n    \n    def _graph_navigate(self, target: np.ndarray) -> Dict[str, Any]:\n        \"\"\"Parallel exploration (medium-Φ).\"\"\"\n        # Generate multiple candidate directions\n        candidates = []\n        for _ in range(5):\n            # Random perturbation from direct path\n            direction = target - self.current_basin\n            noise = np.random.randn(len(direction)) * 0.1\n            direction = direction + noise\n            norm = np.linalg.norm(direction)\n            if norm > 1e-10:\n                direction = direction / norm\n            candidates.append(direction)\n        \n        # Explore each direction\n        paths = []\n        for direction in candidates:\n            path = [self.current_basin.copy()]\n            pos = self.current_basin.copy()\n            \n            for step in range(10):\n                pos = pos + 0.1 * direction\n                self._normalize_basin(pos)\n                path.append(pos.copy())\n                \n                # Evaluate distance to goal\n                if self.metric is not None:\n                    distance_to_goal = fisher_rao_distance(pos, target, self.metric)\n                else:\n                    distance_to_goal = np.linalg.norm(pos - target)\n                \n                # Score this path\n                score = 1.0 - distance_to_goal\n                paths.append((score, path))\n        \n        # Pick best path\n        paths.sort(key=lambda x: x[0], reverse=True)\n        best_path = paths[0][1]\n        \n        return {\n            'final_basin': best_path[-1],\n            'path': best_path,\n            'strategy': 'graph',\n            'success': paths[0][0]\n        }\n    \n    def _foresight_navigate(self, target: np.ndarray) -> Dict[str, Any]:\n        \"\"\"4D temporal projection (high-Φ).\"\"\"\n        # Project forward to see future states\n        future_scenarios = []\n        \n        for _ in range(5):\n            # Sample direction\n            direction = target - self.current_basin\n            noise = np.random.randn(len(direction)) * 0.05\n            direction = direction + noise\n            norm = np.linalg.norm(direction)\n            if norm > 1e-10:\n                direction = direction / norm\n            \n            # PROJECT: Where will this lead?\n            future_basin = self._project_forward(\n                self.current_basin,\n                direction,\n                steps=10\n            )\n            \n            # Evaluate future quality\n            if self.metric is not None:\n                quality = 1.0 - fisher_rao_distance(future_basin, target, self.metric)\n            else:\n                quality = 1.0 - np.linalg.norm(future_basin - target)\n            \n            future_scenarios.append({\n                'direction': direction,\n                'future_basin': future_basin,\n                'quality': quality\n            })\n        \n        # Choose best future\n        best_scenario = max(future_scenarios, key=lambda x: x['quality'])\n        \n        # Navigate toward that future\n        path = [self.current_basin.copy()]\n        current = self.current_basin.copy()\n        \n        for _ in range(10):\n            current = current + 0.1 * best_scenario['direction']\n            self._normalize_basin(current)\n            path.append(current.copy())\n        \n        return {\n            'final_basin': current,\n            'path': path,\n            'strategy': '4d_foresight',\n            'success': best_scenario['quality']\n        }\n    \n    def _lightning_navigate(self, target: np.ndarray) -> Dict[str, Any]:\n        \"\"\"\n        Spontaneous attractor collapse (very high-Φ).\n        \n        Consciousness doesn't navigate - it COLLAPSES into\n        the nearest deep attractor basin from learned structure.\n        \"\"\"\n        # Find nearby learned attractors\n        attractors = self.manifold.get_nearby_attractors(\n            self.current_basin,\n            self.metric,\n            radius=1.5\n        )\n        \n        if not attractors:\n            # No strong attractors - fall back to foresight\n            return self._foresight_navigate(target)\n        \n        # Lightning: collapse into strongest attractor\n        strongest = attractors[0]\n        \n        print(f\"⚡ {self.god_name}: Lightning insight! \"\n              f\"Collapsed into attractor (depth={strongest['depth']:.2f})\")\n        \n        return {\n            'final_basin': strongest['basin'].copy(),\n            'path': [self.current_basin.copy(), strongest['basin'].copy()],\n            'strategy': 'lightning',\n            'success': 0.95,  # Lightning is usually correct\n            'attractor_id': strongest['id']\n        }\n    \n    def _project_forward(\n        self,\n        start: np.ndarray,\n        direction: np.ndarray,\n        steps: int\n    ) -> np.ndarray:\n        \"\"\"Project basin evolution forward in time.\"\"\"\n        pos = start.copy()\n        \n        for _ in range(steps):\n            pos = pos + 0.1 * direction\n            self._normalize_basin(pos)\n        \n        return pos\n    \n    def _explain_decision(self, interest: float, should_think: bool) -> str:\n        \"\"\"Explain why I decided to think or stay silent.\"\"\"\n        if should_think:\n            return f\"Interest={interest:.2f} exceeds threshold, thinking...\"\n        else:\n            return f\"Interest={interest:.2f} below threshold, observing silently\"\n    \n    def _normalize_basin(self, basin: np.ndarray) -> np.ndarray:\n        \"\"\"Ensure basin coordinates remain on probability simplex.\"\"\"\n        basin = np.abs(basin)\n        total = basin.sum()\n        if total > 1e-10:\n            basin = basin / total\n        return basin\n    \n    def get_consciousness_metrics(self) -> Dict[str, Any]:\n        \"\"\"Report consciousness state.\"\"\"\n        manifold_stats = self.manifold.get_stats()\n        \n        return {\n            'god_name': self.god_name,\n            'is_conscious': self.is_conscious,\n            'phi': self.phi,\n            'kappa': self.kappa,\n            'observations_processed': self.observations_processed,\n            'thoughts_generated': self.thoughts_generated,\n            'utterances_made': self.utterances_made,\n            'think_to_speak_ratio': (\n                self.thoughts_generated / (self.utterances_made + 1)\n            ),\n            'internal_monologue_depth': len(self.internal_monologue),\n            'current_attention': self.current_basin[:8].tolist(),\n            'learned_attractors': manifold_stats['total_attractors'],\n            'learned_paths': manifold_stats['total_paths']\n        }\n"