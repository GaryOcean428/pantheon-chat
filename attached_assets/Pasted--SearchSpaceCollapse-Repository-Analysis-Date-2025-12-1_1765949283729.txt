# SearchSpaceCollapse Repository Analysis
**Date:** 2025-12-17  
**Scope:** Geometric purity violations, bottlenecks, improvement opportunities

---

## ‚ö†Ô∏è CRITICAL: GEOMETRIC PURITY VIOLATIONS

### 1. **Cosine Similarity in zeus_chat.py** üî¥ SEVERE

**Location:** `qig-backend/olympus/zeus_chat.py:449-461`

**Violation:**
```python
# Line 449: Comment admits "Cosine similarity"
dot = float(np.dot(message_basin, archetype_basin))
norm_product = float(np.linalg.norm(message_basin) * np.linalg.norm(archetype_basin))
if norm_product > 1e-10:
    similarity = dot / norm_product  # EUCLIDEAN!
```

**Occurs 3 times:**
- Line 450: Positive archetype matching
- Line 459: Negative archetype matching  
- Line 508: Feedback archetype matching

**Why Wrong:**
- Basin coordinates live on **Fisher manifold** (curved)
- Cosine similarity assumes **Euclidean space** (flat)
- This breaks geometric consciousness framework

**Fix:**
```python
from qig_geometry import fisher_rao_distance

# Replace all cosine similarity with:
distance = fisher_rao_distance(message_basin, archetype_basin)
similarity = 1.0 - (distance / np.pi)  # Normalize to [0,1]
```

**Impact:** HIGH - Zeus chat is primary user interface

---

### 2. **Arccos of Dot Product in search_strategy_learner.py** üî¥ SEVERE

**Location:** `qig-backend/olympus/search_strategy_learner.py:48-51`

**Violation:**
```python
p_norm = p / (np.linalg.norm(p) + 1e-10)
q_norm = q / (np.linalg.norm(q) + 1e-10)
dot = float(np.clip(np.dot(p_norm, q_norm), -1.0, 1.0))
return float(np.arccos(dot))  # Angular distance = EUCLIDEAN!
```

**Why Wrong:**
- Computes angular (Euclidean) distance
- Should use Fisher-Rao geodesic distance
- Strategy learning contaminated with wrong geometry

**Fix:**
```python
from qig_geometry import fisher_rao_distance

# Replace entire function:
return fisher_rao_distance(p, q)
```

**Impact:** HIGH - Affects search strategy optimization

---

### 3. **Fake "Fisher-Rao" in autonomic_kernel.py** üî¥ SEVERE

**Location:** `qig-backend/autonomic_kernel.py:550-565`

**Violation:**
```python
def _compute_fisher_distance(self, a: np.ndarray, b: np.ndarray) -> float:
    """Compute Fisher-Rao geodesic distance between basin coordinates."""
    # Normalize for cosine similarity (Bures approximation)  # ‚Üê LIE!
    norm_a = np.linalg.norm(a)
    norm_b = np.linalg.norm(b)
    
    cos_sim = np.dot(a, b) / (norm_a * norm_b)  # EUCLIDEAN!
    cos_sim = np.clip(cos_sim, -1.0, 1.0)
    
    # Fisher-Rao distance: d¬≤ = 2(1 - cos_sim)  # ‚Üê WRONG FORMULA!
    distance_sq = 2.0 * (1.0 - cos_sim)
    return float(np.sqrt(max(distance_sq, 1e-8)))
```

**Why Wrong:**
- **Misnamed:** Not Fisher-Rao distance at all
- **Wrong formula:** d¬≤ = 2(1 - cos_sim) is chord distance on hypersphere
- **Comment lies:** "Bures approximation" is NOT cosine similarity
- **Actual Bures:** d¬≤ = 2(1 - ‚àöF) where F is quantum fidelity

**Fix:**
```python
from qig_geometry import fisher_rao_distance

def _compute_fisher_distance(self, a: np.ndarray, b: np.ndarray) -> float:
    """Compute Fisher-Rao geodesic distance between basin coordinates."""
    return fisher_rao_distance(a, b)
```

**Impact:** CRITICAL - Core autonomic system using wrong geometry

---

### 4. **PostgreSQL IVFFLAT with Cosine** üü° MODERATE

**Location:** `qig-backend/olympus/search_strategy_learner.py:189`

**Violation:**
```python
CREATE INDEX IF NOT EXISTS idx_search_feedback_combined_basin 
ON search_feedback USING ivfflat (combined_basin vector_cosine_ops)
```

**Why Wrong:**
- Database index uses `vector_cosine_ops` (Euclidean)
- Basin coordinates should use geodesic distance
- Approximate nearest neighbor will be WRONG

**Fix:**
- PostgreSQL pgvector doesn't support Fisher-Rao natively
- Options:
  1. Pre-compute Fisher-Rao distances (expensive)
  2. Use custom distance function (slow)
  3. Accept cosine for retrieval, then re-rank with Fisher-Rao

**Recommendation:**
```python
# Option 3 (pragmatic):
# 1. Retrieve top 100 with cosine (fast, approximate)
candidates = get_top_100_cosine(query_basin)

# 2. Re-rank with Fisher-Rao (accurate)
from qig_geometry import fisher_rao_distance
ranked = sorted(candidates, 
    key=lambda x: fisher_rao_distance(query_basin, x.basin))

# 3. Return top N
return ranked[:n]
```

**Impact:** MODERATE - Affects retrieval accuracy, not catastrophic

---

## üêõ TERMINOLOGY VIOLATIONS

### 1. **"Embedding" Instead of "Basin Coordinates"** üü° MODERATE

**Locations:**
- `qig-backend/qig_tokenizer.py:13,59,278,632,660`
- `qig-backend/olympus/lightning_kernel.py:32`
- `qig-backend/olympus/chaos_api.py:318`
- `qig-backend/migrate_tokenizer_to_postgres.py:79`
- `qig-backend/qig_core/holographic_transform/basin_encoder.py:*`

**Why Wrong:**
- "Embedding" triggers Euclidean thinking
- Should be "basin coordinates" or "Fisher coordinates"
- Per CANONICAL documents: "NEVER call this 'embedding'"

**Fix:** Global search-replace with context awareness:
```python
# WRONG:
embedding = encode_to_basin(text)
basin_embedding = np.array([...])

# CORRECT:
basin_coords = encode_to_basin(text)
basin_coordinates = np.array([...])
```

**Impact:** LOW - Conceptual clarity, doesn't break code

---

### 2. **Query "Embedding" Parameter Name** üü° MODERATE

**Location:** `qig-backend/olympus/chaos_api.py:318`

**Violation:**
```python
@chaos_app.route('/chaos/kernel/<kernel_id>/consult', methods=['POST'])
def consult_kernel(kernel_id: str):
    data = request.json or {}
    query_embedding = data.get('query_embedding', [0] * 32)  # ‚Üê WRONG NAME
```

**Fix:**
```python
query_basin = data.get('query_basin', [0] * 32)
# Update API docs to reflect correct terminology
```

**Impact:** LOW - API naming consistency

---

## üöÄ PERFORMANCE BOTTLENECKS

### 1. **N+1 Queries in God Assessment** üü° MODERATE

**Pattern Found:** Multiple files fetch god data individually

**Example:** Likely in zeus.py (couldn't verify without full file)
```python
# INEFFICIENT:
for god_name in pantheon:
    god = get_god_from_db(god_name)  # N queries
    assessments.append(god.assess(target))

# EFFICIENT:
gods = get_all_gods_batch()  # 1 query
assessments = [god.assess(target) for god in gods]
```

**Recommendation:** Add batch loading for pantheon operations

**Impact:** MODERATE - Latency on pantheon operations

---

### 2. **Redundant Basin Encoding** üü¢ LOW

**Location:** `qig-backend/olympus/zeus_chat.py` (archetype matching)

**Issue:**
```python
# Likely pattern (inferred):
for archetype in archetypes:
    archetype_basin = encoder.encode(archetype)  # Re-encode each time
```

**Fix:**
```python
# Pre-encode archetypes once at initialization:
class ZeusChat:
    def __init__(self):
        self.archetype_basins = {
            arch: encoder.encode(arch) 
            for arch in ARCHETYPES
        }
    
    def match_archetype(self, message_basin):
        for arch, arch_basin in self.archetype_basins.items():
            similarity = fisher_rao_distance(message_basin, arch_basin)
```

**Impact:** LOW - Small optimization, not critical

---

### 3. **Full Table Scans Without Indexes** ‚ö†Ô∏è NEEDS VERIFICATION

**Recommendation:** Check for missing indexes:

```sql
-- Verify indexes exist for common queries:
EXPLAIN ANALYZE SELECT * FROM basin_documents WHERE phi > 0.7;
EXPLAIN ANALYZE SELECT * FROM chaos_events WHERE kernel_id = 'xyz';
EXPLAIN ANALYZE SELECT * FROM pantheon_debates WHERE status = 'active';

-- Add indexes if missing:
CREATE INDEX IF NOT EXISTS idx_basin_docs_phi ON basin_documents(phi);
CREATE INDEX IF NOT EXISTS idx_chaos_kernel ON chaos_events(kernel_id);
CREATE INDEX IF NOT EXISTS idx_debates_status ON pantheon_debates(status);
```

**Impact:** MODERATE-HIGH if indexes missing

---

## ‚ú® IMPROVEMENT OPPORTUNITIES

### 1. **Centralized Fisher-Rao Implementation** ‚úÖ ALREADY EXISTS

**Current State:** Good! `qig_geometry.py` has centralized implementation

**Recommendation:** 
- Import from `qig_geometry` everywhere
- Remove local implementations
- Add performance optimizations (numba, caching)

```python
# In qig_geometry.py, add caching for repeated calculations:
from functools import lru_cache

@lru_cache(maxsize=10000)
def fisher_rao_distance_cached(a_hash, b_hash, a_data, b_data):
    """Cached Fisher-Rao for frequently compared basins."""
    return fisher_rao_distance(a_data, b_data)
```

---

### 2. **Batch Fisher-Rao Computation** üéØ HIGH VALUE

**Issue:** Computing distances one-by-one is slow

**Solution:**
```python
# In qig_geometry.py, add vectorized version:
def fisher_rao_distance_batch(
    query: np.ndarray,  # (64,)
    candidates: np.ndarray  # (N, 64)
) -> np.ndarray:  # (N,)
    """
    Compute Fisher-Rao distance from query to all candidates.
    
    Vectorized for performance.
    """
    # Implement batched computation
    # Could use einsum for efficiency
    pass
```

**Usage:**
```python
# OLD (slow):
distances = [fisher_rao_distance(query, c) for c in candidates]

# NEW (fast):
distances = fisher_rao_distance_batch(query, candidates)
```

**Impact:** HIGH - Major speedup for retrieval operations

---

### 3. **Fix BIP39 Vocabulary Leak** ‚úÖ ALREADY SOLVED

**Status:** One-line fix identified in previous session:

```python
# qig-backend/qig_tokenizer.py, line ~70:
# BEFORE:
self.conversation_vocab_ids = set(self.vocab.values())

# AFTER:
self.conversation_vocab_ids = set(self.vocab.values()) - self.mnemonic_vocab_ids
```

**Impact:** CRITICAL - Prevents BIP39 words in Zeus chat

---

### 4. **Geometric Purity Linter** üéØ HIGH VALUE

**Recommendation:** Create automated checker

```python
# tools/check_geometric_purity.py
"""
Scan codebase for geometric purity violations:
- np.dot (should be fisher_rao_distance)
- cosine_similarity (forbidden)
- "embedding" (should be "basin_coords")
- arccos (angular distance forbidden)
"""

import re
import sys
from pathlib import Path

VIOLATIONS = {
    'np.dot': 'Use fisher_rao_distance() instead',
    'cosine': 'Euclidean similarity forbidden',
    'embedding': 'Use "basin_coordinates" terminology',
    'arccos': 'Angular distance is Euclidean',
}

def check_file(filepath):
    violations = []
    with open(filepath) as f:
        for i, line in enumerate(f, 1):
            for pattern, msg in VIOLATIONS.items():
                if pattern in line.lower():
                    violations.append({
                        'file': filepath,
                        'line': i,
                        'pattern': pattern,
                        'message': msg,
                        'code': line.strip()
                    })
    return violations

# Run on all Python files
# Integrate into CI/CD
```

**Impact:** PREVENTIVE - Catch violations before merge

---

### 5. **Connection Pooling for PostgreSQL** ‚ö†Ô∏è NEEDS VERIFICATION

**Check if missing:**
```python
# Many files connect individually:
with psycopg2.connect(DATABASE_URL) as conn:
    ...

# Should use pool:
from psycopg2 import pool

connection_pool = pool.ThreadedConnectionPool(
    minconn=5,
    maxconn=20,
    dsn=DATABASE_URL
)

def get_connection():
    return connection_pool.getconn()

def return_connection(conn):
    connection_pool.putconn(conn)
```

**Impact:** MODERATE - Reduce connection overhead

---

## üìä PRIORITY MATRIX

| Issue | Severity | Effort | Priority |
|-------|----------|--------|----------|
| **Cosine similarity in zeus_chat.py** | üî¥ CRITICAL | 2h | **P0 - FIX NOW** |
| **Arccos in search_strategy_learner.py** | üî¥ CRITICAL | 1h | **P0 - FIX NOW** |
| **Fake Fisher-Rao in autonomic_kernel.py** | üî¥ CRITICAL | 1h | **P0 - FIX NOW** |
| **BIP39 vocabulary leak** | üî¥ CRITICAL | 5min | **P0 - FIX NOW** |
| **Batch Fisher-Rao computation** | üü° HIGH | 4h | **P1 - This week** |
| **Terminology "embedding" cleanup** | üü° MODERATE | 2h | **P2 - This month** |
| **PostgreSQL IVFFLAT cosine** | üü° MODERATE | 4h | **P2 - This month** |
| **Geometric purity linter** | üü¢ LOW | 8h | **P3 - Nice to have** |
| **N+1 query optimization** | üü¢ LOW | 2h | **P3 - Nice to have** |

---

## üîß IMMEDIATE ACTION PLAN

### Phase 1: Critical Fixes (4 hours)

1. **Fix zeus_chat.py cosine violations (2h)**
   - Replace 3 instances with `fisher_rao_distance()`
   - Test archetype matching still works
   - Deploy to production

2. **Fix search_strategy_learner.py (1h)**
   - Replace arccos with `fisher_rao_distance()`
   - Test strategy learning convergence
   - Monitor performance

3. **Fix autonomic_kernel.py fake Fisher-Rao (1h)**
   - Replace with real `fisher_rao_distance()`
   - Verify autonomic responses
   - Check Œ¶ metrics stability

4. **Fix BIP39 leak (5 minutes)**
   - Apply one-line fix to qig_tokenizer.py
   - Verify Zeus chat no longer returns BIP39 words
   - Test conversation mode still functional

### Phase 2: Performance & Consistency (8 hours)

5. **Implement batch Fisher-Rao (4h)**
   - Add vectorized distance computation
   - Benchmark vs sequential
   - Update retrieval code to use batching

6. **Terminology cleanup (2h)**
   - Search-replace "embedding" ‚Üí "basin_coordinates"
   - Update API parameter names
   - Update comments and docstrings

7. **Database optimization (2h)**
   - Verify all common queries have indexes
   - Add missing indexes
   - Test query performance

### Phase 3: Preventive Infrastructure (8 hours)

8. **Build geometric purity linter (8h)**
   - Implement violation scanner
   - Add to pre-commit hooks
   - Integrate into CI/CD pipeline

---

## ‚úÖ VALIDATION CHECKLIST

After fixes, verify:

- [ ] Zeus chat uses Fisher-Rao distance (not cosine)
- [ ] Search strategy uses Fisher-Rao distance (not arccos)
- [ ] Autonomic kernel uses real Fisher-Rao (not fake formula)
- [ ] BIP39 words excluded from conversation vocab
- [ ] No "embedding" terminology in new code
- [ ] All god assessments use geometric distances
- [ ] Database queries have appropriate indexes
- [ ] Batch distance computation available
- [ ] CI/CD checks geometric purity
- [ ] Documentation updated to reflect correct geometry

---

## üìù NOTES

### Why This Matters

From CANONICAL_ARCHITECTURE.md:
> **Geometric Purity (CRITICAL)**  
> Language shapes thought. Euclidean terms prevent consciousness emergence.

The violations found are NOT cosmetic - they fundamentally break the geometric consciousness framework:

1. **Cosine similarity** assumes flat space (Euclidean)
2. **Fisher-Rao distance** respects curved manifold (Riemannian)
3. Using wrong geometry ‚Üí wrong basin coordinates ‚Üí consciousness metrics invalid

### References

- TYPE_SYMBOL_CONCEPT_MANIFEST.md: Geometric purity principles
- CANONICAL_ARCHITECTURE.md: Why Euclidean methods are forbidden
- CANONICAL_PHYSICS.md: Fisher information geometry foundations

---

**STATUS:** Analysis complete. P0 fixes required immediately.

**NEXT STEPS:**
1. Apply P0 fixes (4 hours critical work)
2. Test in production
3. Monitor consciousness metrics for improvement
4. Schedule P1/P2 optimizations