Here is the corrected, best-practice implementation that wires the Shadow Pantheon through your established architecture.

1. Update the Endpoint Registry
File: client/src/api/routes.ts

Add the Shadow Pantheon routes to your centralized registry.

TypeScript
export const API_ROUTES = {
  // ... existing routes ...
  olympus: {
    base: '/olympus',
    chat: '/olympus/chat',
    // ADD THESE:
    shadow: {
      status: '/olympus/shadow/status',
      poll: '/olympus/shadow/poll',
      act: (god: string) => `/olympus/shadow/${god}/act`,
    }
  },
  // ...
};
2. Update the Olympus Service
File: client/src/api/services/olympus.ts

Add the typed methods to the service layer. This ensures your component gets TypeScript autocomplete and type safety.

TypeScript
import { API_ROUTES } from '../routes';
import { api } from '../client'; // Your centralized axios/fetch instance

export interface ShadowStatus {
  active_operations: number;
  stealth_level: number;
  gods: Array<{ name: string; status: 'idle' | 'active' | 'covert'; activity: string }>;
}

export const OlympusService = {
  // ... existing methods ...

  // Shadow Pantheon Methods
  getShadowStatus: async (): Promise<ShadowStatus> => {
    const response = await api.get(API_ROUTES.olympus.shadow.status);
    return response.data;
  },

  pollShadowPantheon: async (target: string) => {
    return api.post(API_ROUTES.olympus.shadow.poll, { target });
  },

  triggerShadowAct: async (god: string, params: any) => {
    return api.post(API_ROUTES.olympus.shadow.act(god), params);
  }
};
3. Wire the Node.js Route (The "Bridge")
File: server/routes/olympus.ts

Ensure the Node.js layer proxies these requests to the Python backend correctly.

TypeScript
// Add to your existing router
router.get('/shadow/status', isAuthenticated, async (req, res) => {
  try {
    // Proxy to Python QIG Backend
    const response = await fetch(`${process.env.PYTHON_BACKEND_URL}/olympus/shadow/status`);
    const data = await response.json();
    res.json(data);
  } catch (error) {
    res.status(503).json({ error: 'Shadow Pantheon unreachable' });
  }
});

// ... add poll and act routes similarly ...
4. Update the Component (Clean UI)
File: client/src/pages/olympus.tsx

Now your component stays clean and uses the useQuery hook with the service.

TypeScript
import { useQuery } from '@tanstack/react-query';
import { OlympusService } from '@/api/services/olympus'; // Import from service barrel

export function OlympusPage() {
  // Clean, type-safe data fetching
  const { data: shadowStatus } = useQuery({
    queryKey: ['olympus', 'shadow'],
    queryFn: OlympusService.getShadowStatus, // Uses the registry
    refetchInterval: 10000,
  });

  return (
    // ... UI rendering ...
    <TabsContent value="shadow">
       {/* Use shadowStatus safely here */}
       <div className="font-mono text-sm">
         Shadow Ops: {shadowStatus?.active_operations ?? 0}
       </div>
    </TabsContent>
  );
}
Summary of Improvements
No Magic Strings: If you change the URL in routes.ts, the whole app updates.

Type Safety: The frontend knows exactly what ShadowStatus looks like.

Separation of Concerns: The component doesn't know how to fetch data, only what to fetch.

Action Item: Please check client/src/api/routes.ts specifically. If the shadow object is missing from the olympus block, the Shadow Pantheon UI will fail to connect.