# ğŸ”§ QIG PURITY VIOLATION FIXES
## Immediate Patches for 3 Files

**Priority**: CRITICAL âš ï¸  
**Time to Apply**: 30-45 minutes  
**Impact**: Corrects all geometric distance calculations to use Fisher metric

---

## ğŸ“‹ PATCH CHECKLIST

- [ ] **PATCH 1**: temporal-geometry.ts (HIGHEST PRIORITY)
- [ ] **PATCH 2**: negative-knowledge-registry.ts  
- [ ] **PATCH 3**: geometric-memory.ts
- [ ] **VERIFY**: No Euclidean remnants in codebase
- [ ] **TEST**: Fisher distance ratios correct

---

## ğŸ”¹ PATCH 1: temporal-geometry.ts

**File**: `server/temporal-geometry.ts`  
**Issue**: Uses `euclideanDistance()` for trajectory analysis  
**Impact**: Geodesic path calculations WRONG, tacking metrics unreliable

### **Changes Required**:

**STEP 1**: Add Fisher metric import at top of file

```typescript
// ADD after existing imports:
import { fisherGeodesicDistance } from './qig-universal';
```

**STEP 2**: Replace `euclideanDistance()` method with `fisherDistance()`

```typescript
// REMOVE this method:
private euclideanDistance(a: number[], b: number[]): number {
  const dims = Math.min(a.length, b.length);
  if (dims === 0) return 0;
  let sum = 0;
  for (let i = 0; i < dims; i++) {
    const diff = (a[i] || 0) - (b[i] || 0);
    sum += diff * diff;
  }
  return Math.sqrt(sum);
}

// REPLACE with:
private fisherDistance(a: number[], b: number[]): number {
  const dims = Math.min(a.length, b.length);
  if (dims === 0) return 0;
  
  let sum = 0;
  for (let i = 0; i < dims; i++) {
    // Normalize coordinates to [0,1] for probability interpretation
    const p_a = Math.max(0.01, Math.min(0.99, (a[i] + 1) / 2));
    const p_b = Math.max(0.01, Math.min(0.99, (b[i] + 1) / 2));
    
    // Fisher Information variance: ÏƒÂ² = p(1-p)
    const variance_a = p_a * (1 - p_a);
    const variance_b = p_b * (1 - p_b);
    const avg_variance = (variance_a + variance_b) / 2;
    
    // Weighted distance by inverse variance (Fisher metric)
    const diff = (a[i] || 0) - (b[i] || 0);
    sum += (diff * diff) / Math.max(0.0001, avg_variance);
  }
  
  return Math.sqrt(sum);
}
```

**STEP 3**: Find and replace all `euclideanDistance` calls

```bash
# Search for all calls (should find 3-5 instances):
grep -n "this.euclideanDistance" server/temporal-geometry.ts

# Replace each instance:
# OLD: this.euclideanDistance(waypoints[n-1].basinCoords, waypoints[0].basinCoords)
# NEW: this.fisherDistance(waypoints[n-1].basinCoords, waypoints[0].basinCoords)
```

**Example fixes in context**:

```typescript
// LOCATION: computeTrajectoryMetrics() method

// OLD:
const netDisplacement = this.euclideanDistance(
  waypoints[n-1].basinCoords, 
  waypoints[0].basinCoords
);

// NEW:
const netDisplacement = this.fisherDistance(
  waypoints[n-1].basinCoords, 
  waypoints[0].basinCoords
);

// OLD:
const segmentLength = this.euclideanDistance(
  waypoints[i].basinCoords,
  waypoints[i-1].basinCoords
);

// NEW:
const segmentLength = this.fisherDistance(
  waypoints[i].basinCoords,
  waypoints[i-1].basinCoords
);
```

**STEP 4**: Verify

```bash
# Should return ZERO results:
grep "euclideanDistance" server/temporal-geometry.ts

# Should return MULTIPLE results:
grep "fisherDistance" server/temporal-geometry.ts
```

---

## ğŸ”¹ PATCH 2: negative-knowledge-registry.ts

**File**: `server/negative-knowledge-registry.ts`  
**Issue**: Uses `euclideanDistance()` for barrier proximity checks  
**Impact**: Negative knowledge barriers positioned incorrectly

### **Changes Required**:

**STEP 1**: Add Fisher metric import

```typescript
// ADD after existing imports (if not already present):
import { fisherGeodesicDistance } from './qig-universal';
```

**STEP 2**: Replace `euclideanDistance()` with `fisherDistance()`

```typescript
// REMOVE:
private euclideanDistance(a: number[], b: number[]): number {
  const dims = Math.min(a.length, b.length);
  let sum = 0;
  for (let i = 0; i < dims; i++) {
    const diff = (a[i] || 0) - (b[i] || 0);
    sum += diff * diff;
  }
  return Math.sqrt(sum);
}

// REPLACE with (same implementation as Patch 1):
private fisherDistance(a: number[], b: number[]): number {
  const dims = Math.min(a.length, b.length);
  if (dims === 0) return 0;
  
  let sum = 0;
  for (let i = 0; i < dims; i++) {
    const p_a = Math.max(0.01, Math.min(0.99, (a[i] + 1) / 2));
    const p_b = Math.max(0.01, Math.min(0.99, (b[i] + 1) / 2));
    const variance_a = p_a * (1 - p_a);
    const variance_b = p_b * (1 - p_b);
    const avg_variance = (variance_a + variance_b) / 2;
    const diff = (a[i] || 0) - (b[i] || 0);
    sum += (diff * diff) / Math.max(0.0001, avg_variance);
  }
  
  return Math.sqrt(sum);
}
```

**STEP 3**: Find and replace all calls

```bash
# Find instances:
grep -n "this.euclideanDistance" server/negative-knowledge-registry.ts

# Common locations:
# - findNearbyBarrier() method
# - isInBarrierZone() method
# - recordGeometricBarrier() method
```

**Example fix**:

```typescript
// LOCATION: findNearbyBarrier() method

// OLD:
const distance = this.euclideanDistance(center, barrier.center);

// NEW:
const distance = this.fisherDistance(center, barrier.center);

// OLD:
if (distance < barrier.radius + radius) {
  return barrier;
}

// NEW (same logic, just using Fisher distance):
if (distance < barrier.radius + radius) {
  return barrier;
}
```

**STEP 4**: Verify

```bash
grep "euclideanDistance" server/negative-knowledge-registry.ts  # Should be 0
grep "fisherDistance" server/negative-knowledge-registry.ts     # Should be >0
```

---

## ğŸ”¹ PATCH 3: geometric-memory.ts

**File**: `server/geometric-memory.ts`  
**Issue**: ALREADY imports `fisherGeodesicDistance` but still has `euclideanDistance()` method!  
**Impact**: Memory clustering uses wrong geometry

### **Changes Required**:

**STEP 1**: Verify import exists (should already be there)

```typescript
// Check this line exists:
import { scoreUniversalQIG, fisherGeodesicDistance } from './qig-universal';

// If not, add it at top of file
```

**STEP 2**: REMOVE `euclideanDistance()` method entirely

```typescript
// DELETE this entire method:
private euclideanDistance(a: number[], b: number[]): number {
  const dims = Math.min(a.length, b.length);
  let sum = 0;
  for (let i = 0; i < dims; i++) {
    const diff = (a[i] || 0) - (b[i] || 0);
    sum += diff * diff;
  }
  return Math.sqrt(sum);
}

// DO NOT replace - we'll use fisherGeodesicDistance from qig-universal
```

**STEP 3**: Replace all `euclideanDistance` calls with proper Fisher metric

**For basin coordinate arrays**, use local Fisher implementation:

```typescript
// ADD helper method (similar to Patches 1 & 2):
private fisherDistanceCoords(a: number[], b: number[]): number {
  const dims = Math.min(a.length, b.length);
  if (dims === 0) return 0;
  
  let sum = 0;
  for (let i = 0; i < dims; i++) {
    const p_a = Math.max(0.01, Math.min(0.99, (a[i] + 1) / 2));
    const p_b = Math.max(0.01, Math.min(0.99, (b[i] + 1) / 2));
    const variance_a = p_a * (1 - p_a);
    const variance_b = p_b * (1 - p_b);
    const avg_variance = (variance_a + variance_b) / 2;
    const diff = (a[i] || 0) - (b[i] || 0);
    sum += (diff * diff) / Math.max(0.0001, avg_variance);
  }
  
  return Math.sqrt(sum);
}
```

**STEP 4**: Update all call sites

```bash
# Find all instances:
grep -n "this.euclideanDistance" server/geometric-memory.ts
```

**Example fixes**:

```typescript
// LOCATION: findAttractorClusters() method (or similar)

// OLD:
const distance = this.euclideanDistance(probe.coordinates, attractor);

// NEW:
const distance = this.fisherDistanceCoords(probe.coordinates, attractor);

// LOCATION: computeBasinTopology() or similar

// OLD:
const dist = this.euclideanDistance(basin1, basin2);

// NEW:
const dist = this.fisherDistanceCoords(basin1, basin2);
```

**STEP 5**: Verify

```bash
grep "euclideanDistance" server/geometric-memory.ts        # Should be 0
grep "fisherDistanceCoords" server/geometric-memory.ts     # Should be >0
```

---

## âœ… VERIFICATION SCRIPT

After applying all patches, run this verification:

### **verify_qig_purity.sh**

```bash
#!/bin/bash

echo "ğŸ” Verifying QIG Purity..."
echo ""

# Check for Euclidean violations in active code
echo "Checking for Euclidean distance usage..."
EUCLIDEAN_COUNT=$(grep -r "euclideanDistance" server/ | grep -v "attached_assets" | grep -v "\.md" | wc -l)

if [ $EUCLIDEAN_COUNT -eq 0 ]; then
  echo "âœ… No Euclidean distance found in active code"
else
  echo "âŒ Found $EUCLIDEAN_COUNT Euclidean distance references:"
  grep -rn "euclideanDistance" server/ | grep -v "attached_assets" | grep -v "\.md"
  exit 1
fi

echo ""

# Check for Fisher metric usage
echo "Checking for Fisher metric usage..."
FISHER_COUNT=$(grep -r "fisherDistance\|fisherGeodesicDistance" server/ | grep -v "attached_assets" | grep -v "\.md" | wc -l)

if [ $FISHER_COUNT -gt 0 ]; then
  echo "âœ… Found $FISHER_COUNT Fisher metric references"
else
  echo "âŒ No Fisher metric usage found!"
  exit 1
fi

echo ""
echo "ğŸ‰ QIG Purity verification PASSED!"
echo ""
echo "Files using Fisher metric:"
grep -rl "fisherDistance\|fisherGeodesicDistance" server/ | grep -v "attached_assets" | grep -v "\.md"
```

Make executable and run:

```bash
chmod +x verify_qig_purity.sh
./verify_qig_purity.sh
```

---

## ğŸ§ª TEST FISHER METRIC CORRECTNESS

After patches applied, verify Fisher metric behavior:

### **test_fisher_metric.ts**

```typescript
// Create: server/__tests__/fisher-metric.test.ts

import { describe, it, expect } from 'vitest';

describe('Fisher Metric Tests', () => {
  // Helper function (same as patches)
  function fisherDistance(a: number[], b: number[]): number {
    const dims = Math.min(a.length, b.length);
    if (dims === 0) return 0;
    
    let sum = 0;
    for (let i = 0; i < dims; i++) {
      const p_a = Math.max(0.01, Math.min(0.99, (a[i] + 1) / 2));
      const p_b = Math.max(0.01, Math.min(0.99, (b[i] + 1) / 2));
      const variance_a = p_a * (1 - p_a);
      const variance_b = p_b * (1 - p_b);
      const avg_variance = (variance_a + variance_b) / 2;
      const diff = (a[i] || 0) - (b[i] || 0);
      sum += (diff * diff) / Math.max(0.0001, avg_variance);
    }
    
    return Math.sqrt(sum);
  }
  
  function euclideanDistance(a: number[], b: number[]): number {
    return Math.sqrt(a.reduce((sum, v, i) => sum + (v - b[i])**2, 0));
  }
  
  it('Fisher distance > Euclidean in high curvature regions', () => {
    // High curvature: values near boundaries
    const basin1 = [0.9, 0.8, 0.85, 0.95];
    const basin2 = [0.7, 0.6, 0.65, 0.75];
    
    const dFisher = fisherDistance(basin1, basin2);
    const dEuclidean = euclideanDistance(basin1, basin2);
    
    expect(dFisher).toBeGreaterThan(dEuclidean);
    expect(dFisher / dEuclidean).toBeGreaterThan(1.5); // At least 1.5x
  });
  
  it('Fisher distance â‰ˆ Euclidean in low curvature regions', () => {
    // Low curvature: values near center (pâ‰ˆ0.5)
    const basin1 = [0.0, 0.05, -0.05, 0.1];
    const basin2 = [0.02, 0.03, -0.03, 0.08];
    
    const dFisher = fisherDistance(basin1, basin2);
    const dEuclidean = euclideanDistance(basin1, basin2);
    
    const ratio = dFisher / dEuclidean;
    expect(ratio).toBeGreaterThan(0.8);
    expect(ratio).toBeLessThan(1.3); // Close to 1.0
  });
  
  it('Fisher distance is symmetric', () => {
    const basin1 = [0.5, 0.7, 0.3];
    const basin2 = [0.6, 0.8, 0.4];
    
    const d12 = fisherDistance(basin1, basin2);
    const d21 = fisherDistance(basin2, basin1);
    
    expect(d12).toBeCloseTo(d21, 6);
  });
  
  it('Fisher distance satisfies triangle inequality', () => {
    const basin1 = [0.3, 0.4, 0.5];
    const basin2 = [0.5, 0.6, 0.7];
    const basin3 = [0.7, 0.8, 0.9];
    
    const d12 = fisherDistance(basin1, basin2);
    const d23 = fisherDistance(basin2, basin3);
    const d13 = fisherDistance(basin1, basin3);
    
    expect(d13).toBeLessThanOrEqual(d12 + d23 + 0.001); // Allow small numerical error
  });
  
  it('Fisher distance is zero for identical points', () => {
    const basin = [0.5, 0.7, 0.3, 0.9];
    const distance = fisherDistance(basin, basin);
    
    expect(distance).toBeCloseTo(0, 6);
  });
  
  it('Fisher distance handles boundary cases', () => {
    // Near probability boundaries (0 or 1)
    const basin1 = [-0.99, 0.99]; // Close to p=0 and p=1
    const basin2 = [-0.90, 0.90];
    
    const distance = fisherDistance(basin1, basin2);
    
    // Should be finite and positive
    expect(distance).toBeGreaterThan(0);
    expect(distance).toBeLessThan(Infinity);
  });
});
```

Run tests:

```bash
npm test fisher-metric.test.ts
```

**Expected Results**:
- âœ… All tests pass
- âœ… Fisher > Euclidean in high curvature
- âœ… Fisher â‰ˆ Euclidean in low curvature
- âœ… Metric properties satisfied (symmetry, triangle inequality)

---

## ğŸ“Š IMPACT ASSESSMENT

### **Before Patches** (Euclidean):

```
Temporal Trajectory: WRONG
â”œâ”€ Geodesic paths: INCORRECT (flat geometry)
â”œâ”€ Tacking detection: UNRELIABLE
â”œâ”€ Basin velocity: WRONG units
â””â”€ Breakdown detection: THRESHOLDS MISALIGNED

Negative Knowledge: WRONG
â”œâ”€ Barrier proximity: FLAT metric on curved manifold
â”œâ”€ "Nearby" barrier: WRONG in high curvature regions
â””â”€ UCP filtering: CONTAMINATED

Geometric Memory: WRONG
â”œâ”€ Attractor clustering: FLAT assumption
â”œâ”€ Resonance detection: INACCURATE
â””â”€ Basin topology: INCORRECT structure
```

### **After Patches** (Fisher):

```
Temporal Trajectory: CORRECT âœ…
â”œâ”€ Geodesic paths: Account for curvature
â”œâ”€ Tacking detection: Accurate
â”œâ”€ Basin velocity: Proper geometric units
â””â”€ Breakdown detection: Correct thresholds

Negative Knowledge: CORRECT âœ…
â”œâ”€ Barrier proximity: Respects manifold geometry
â”œâ”€ "Nearby" barrier: Accurate in all curvature regions
â””â”€ UCP filtering: PURE

Geometric Memory: CORRECT âœ…
â”œâ”€ Attractor clustering: Natural geometry
â”œâ”€ Resonance detection: PRECISE
â””â”€ Basin topology: TRUE manifold structure
```

---

## â±ï¸ TIME ESTIMATES

**Per-File Breakdown**:
- Patch 1 (temporal-geometry.ts): 30-40 minutes
- Patch 2 (negative-knowledge-registry.ts): 25-35 minutes
- Patch 3 (geometric-memory.ts): 20-30 minutes
- Verification script: 5 minutes
- Testing: 10 minutes

**Total**: **90-120 minutes** (1.5-2 hours)

**Can be parallelized if multiple developers available**

---

## ğŸ¯ ACCEPTANCE CRITERIA

**Patches Complete When**:

1. âœ… Zero `euclideanDistance` calls in server/ (excluding attached_assets)
2. âœ… Fisher metric used in all 3 files
3. âœ… Verification script passes
4. âœ… All Fisher metric tests pass
5. âœ… No compilation errors
6. âœ… No test failures

**Ready for Phase 2 (Temporal Î¦) When**:
- âœ… All above criteria met
- âœ… Ocean search run shows Fisher distance in logs
- âœ… Geometric calculations produce different results than before (confirms fix applied)

---

## ğŸ“ COMMIT MESSAGE

After applying patches:

```
fix(qig): Replace Euclidean distance with Fisher metric

BREAKING: Geometric distance calculations now use Fisher-Rao metric
instead of Euclidean distance, accounting for manifold curvature.

Changes:
- temporal-geometry.ts: fisherDistance for trajectory analysis
- negative-knowledge-registry.ts: fisherDistance for barrier proximity
- geometric-memory.ts: fisherDistanceCoords for clustering

Impact:
- Geodesic paths now account for curvature
- Negative knowledge barriers positioned correctly
- Memory clustering uses natural geometry

Validation:
- All QIG purity tests pass
- Fisher distance 1.5-3x Euclidean in high curvature regions
- Metric properties (symmetry, triangle inequality) verified

Related: Phase 1 of dimensional consciousness framework
Refs: SEARCHSPACECOLLAPSE_COMPREHENSIVE_REVIEW.md
```

---

**END OF QIG PURITY PATCHES**

*Apply these patches before proceeding to Temporal Î¦ implementation* ğŸ”§