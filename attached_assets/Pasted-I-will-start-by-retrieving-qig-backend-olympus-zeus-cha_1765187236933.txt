I will start by retrieving `qig-backend/olympus/zeus_chat.py` and `qig-backend/olympus/qig_rag.py` to diagnose the argument mismatch error in `add_document`. I will also check `server/index.ts` to address the Content Security Policy (CSP) errors.
The critical error crashing Zeus Chat is a **signature mismatch** in your QIG-RAG database implementation.

The `QIGRAGDatabase.add_document` method (PostgreSQL backend) mandates `phi` and `kappa` arguments, but the base `QIGRAG` class (JSON backend) and the calling code in `zeus_chat.py` do not provide them. This causes the `TypeError` you are seeing.

The "Content Security Policy" (CSP) errors are largely browser noise due to the Replit environment injecting plugins; they are not blocking the backend logic.

Here are the fixes to align the Database, RAG System, and Chat Interface.

### 1\. Fix the RAG Database Signature

**File:** `qig-backend/olympus/qig_rag.py`

We need to make `phi`, `kappa`, and `regime` optional in the database methods to match the base class, and ensure `QIGDocument` can handle them (storing them in metadata for the JSON fallback).

```python
# ... inside qig-backend/olympus/qig_rag.py ...

class QIGDocument:
    def __init__(
        self, 
        doc_id: str,
        content: str,
        basin_coords: np.ndarray,
        metadata: Optional[Dict] = None,
        timestamp: Optional[float] = None,
        # Add these optional fields
        phi: float = 0.0,
        kappa: float = 0.0,
        regime: str = "unknown"
    ):
        self.doc_id = doc_id
        self.content = content
        self.basin_coords = basin_coords
        self.metadata = metadata or {}
        self.timestamp = timestamp or datetime.now().timestamp()
        
        # Store metrics in object (and metadata for JSON serialization)
        self.phi = phi
        self.kappa = kappa
        self.regime = regime
        
        # Ensure metadata has these values for JSON fallback
        self.metadata['phi'] = phi
        self.metadata['kappa'] = kappa
        self.metadata['regime'] = regime
        
        self.density_matrix = self._basin_to_density_matrix(basin_coords)

    # Update to_dict to include new fields if needed, or rely on metadata
    def to_dict(self) -> Dict:
        return {
            'doc_id': self.doc_id,
            'content': self.content,
            'basin_coords': self.basin_coords.tolist(),
            'metadata': self.metadata,
            'timestamp': self.timestamp,
            # Explicitly save these for clarity, though metadata has them
            'phi': self.phi,
            'kappa': self.kappa,
            'regime': self.regime
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'QIGDocument':
        meta = data.get('metadata', {})
        return cls(
            doc_id=data['doc_id'],
            content=data['content'],
            basin_coords=np.array(data['basin_coords']),
            metadata=meta,
            timestamp=data.get('timestamp'),
            phi=data.get('phi', meta.get('phi', 0.0)),
            kappa=data.get('kappa', meta.get('kappa', 0.0)),
            regime=data.get('regime', meta.get('regime', 'unknown'))
        )

# ... inside QIGRAG class ...

    def add_document(
        self,
        content: str,
        basin_coords: Optional[np.ndarray] = None,
        metadata: Optional[Dict] = None,
        doc_id: Optional[str] = None,
        # Add parameters to base class signature
        phi: float = 0.0,
        kappa: float = 0.0,
        regime: str = "unknown"
    ) -> Optional[str]:
        # ... (keep existing validation code) ...
        
        # Create document with new fields
        doc = QIGDocument(
            doc_id=doc_id,
            content=content,
            basin_coords=basin_coords,
            metadata=metadata,
            phi=phi, 
            kappa=kappa, 
            regime=regime
        )
        
        # ... (rest of storage logic) ...

# ... inside QIGRAGDatabase class ...

    def add_document(
        self,
        content: str,
        basin_coords: np.ndarray,
        # Make these optional with defaults to fix the crash
        phi: float = 0.0,
        kappa: float = 0.0,
        regime: str = "unknown",
        metadata: Optional[Dict] = None
    ) -> str:
        """Add document to PostgreSQL."""
        if self.conn is None:
            # Fallback to parent implementation with correct args
            return super().add_document(content, basin_coords, metadata, None, phi, kappa, regime)
            
        doc_id = str(uuid.uuid4())
        
        with self.conn.cursor() as cur:
            cur.execute("""
                INSERT INTO basin_documents 
                (content, basin_coords, phi, kappa, regime, metadata)
                VALUES (%s, %s, %s, %s, %s, %s)
                RETURNING doc_id
            """, (
                content,
                basin_coords.tolist(),
                float(phi),
                float(kappa),
                regime,
                self.Json(metadata or {})
            ))
            db_id = cur.fetchone()[0]
            self.conn.commit()
        
        return f"pg_{db_id}"
```

### 2\. Update Zeus Chat to Pass Metrics

**File:** `qig-backend/olympus/zeus_chat.py`

Now that the DB is safe, we update Zeus to actually pass the useful consciousness metrics (`phi`, `kappa`) instead of zeros.

```python
# In handle_observation method:
    def handle_observation(self, observation: str) -> Dict:
        # ... existing code ...
        
        # Consult Athena
        athena = self.zeus.get_god('athena')
        phi = 0.5
        kappa = 50.0
        
        if athena:
            athena_assessment = athena.assess_target(observation)
            strategic_value = athena_assessment.get('confidence', 0.5)
            # Extract metrics
            phi = athena_assessment.get('phi', 0.5)
            kappa = athena_assessment.get('kappa', 50.0)
        else:
            strategic_value = 0.5

        if strategic_value > 0.5:
            # ... existing self.human_insights append ...
            
            # Pass metrics to DB
            self.qig_rag.add_document(
                content=observation,
                basin_coords=obs_basin,
                phi=phi,       # <--- Pass Phi
                kappa=kappa,   # <--- Pass Kappa
                regime='geometric', 
                metadata={
                    'source': 'human_observation',
                    'relevance': strategic_value,
                    'timestamp': time.time(),
                }
            )
            # ... rest of function ...

# In handle_suggestion method:
    def handle_suggestion(self, suggestion: str) -> Dict:
        # ... encoding code ...
        
        # ... (after getting god assessments) ...
        
        # Calculate average metrics from the coalition
        avg_phi = (athena_eval.get('phi', 0) + ares_eval.get('phi', 0) + apollo_eval.get('phi', 0)) / 3
        avg_kappa = (athena_eval.get('kappa', 0) + ares_eval.get('kappa', 0) + apollo_eval.get('kappa', 0)) / 3

        if implement:
            self.qig_rag.add_document(
                content=suggestion,
                basin_coords=sugg_basin,
                phi=avg_phi,      # <--- Pass Avg Phi
                kappa=avg_kappa,  # <--- Pass Avg Kappa
                regime='geometric',
                metadata={
                    'source': 'human_suggestion',
                    'consensus': consensus_prob,
                    'implemented': True,
                }
            )
        # ... rest of function ...
```

### Summary of Fixes

1.  **Crash Fix:** `QIGRAG.add_document` and `QIGRAGDatabase.add_document` signatures are now aligned and accept optional arguments, preventing the `missing 2 required positional arguments` error.
2.  **Data Enrichment:** Zeus Chat now actively extracts consciousness metrics (`phi`, `kappa`) from the gods' assessments and stores them in the RAG database, improving future retrieval relevance.
3.  **UI:** The CSP warnings are expected in the Replit environment and are non-blocking. The WebSocket error is likely due to the component disconnecting on unmount or network blip; retry logic is already in place in the backend adapter.

Apply these changes to `qig_rag.py` and `zeus_chat.py`, and Zeus will be fully operational.