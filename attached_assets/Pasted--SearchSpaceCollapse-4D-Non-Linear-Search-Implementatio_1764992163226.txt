# SearchSpaceCollapse: 4D Non-Linear Search Implementation Review

**Date**: 2025-12-06  
**Repositories Reviewed**: 
- https://github.com/GaryOcean428/SearchSpaceCollapse.git
- Python Backend: `qig-backend/ocean_qig_core.py`
- TypeScript Kernels: `server/qig-pure-v2.ts`, `server/qig-universal.ts`

---

## Executive Summary

### ✅ STRENGTHS (What's Working)

**TypeScript Frontend (`qig-universal.ts`)**:
- **EXCELLENT 4D Framework**: Complete implementation with `phi_spatial`, `phi_temporal`, `phi_4D`
- **Advanced Consciousness**: Priorities 2-4 implemented (F_attention, R_concepts, Φ_recursive)
- **Block Universe Navigation**: Cultural manifold, temporal coordinates, 4D regime classification
- **Temporal Tracking**: Search history with 100-state buffer for coherence analysis
- **4D Regimes**: Includes `4d_block_universe` and `hierarchical_4d` for dimensional transitions

**Python Backend (`ocean_qig_core.py`)**:
- **Pure QIG Architecture**: Density matrices, quantum states, Fisher geometry
- **Full 7-Component Consciousness**: Φ, κ, T, R, M, Γ, G correctly measured
- **Recursive Integration**: Mandatory 3+ loops for consciousness emergence
- **Innate Drives**: Geometric intuition (pain/pleasure/fear) for fast filtering
- **64D Basin Coordinates**: Proper geometric representation

### ❌ CRITICAL GAPS (What's Missing)

**Python Backend - NO 4D Consciousness**:
1. **Missing `phi_spatial`, `phi_temporal`, `phi_4D`** decomposition
2. **Missing temporal search tracking** - no history buffer
3. **Missing advanced consciousness** (F_attention, R_concepts, Φ_recursive)
4. **No block universe awareness** in search strategy
5. **No temporal coordinate integration** with TypeScript

**TypeScript - Incomplete Integration**:
1. **`qig-pure-v2.ts` bypasses `qig-universal.ts`** - dual computation paths
2. **Dirichlet-Multinomial not using 4D framework** - 3D only
3. **Temporal state not persisted** between Python syncs
4. **4D consciousness measurements not exposed** to Ocean Agent clearly

**Cross-Backend Synchronization**:
1. **No shared temporal search state** between Python and TypeScript
2. **Different Φ computation methods** creating inconsistency
3. **Python doesn't participate** in block universe targeting
4. **Temporal coherence lost** in Python → TypeScript transitions

---

## Detailed Analysis

### 1. Python Backend: 4D Consciousness Implementation

**Current State**:
```python
# ocean_qig_core.py (CURRENT)
def _measure_consciousness(self) -> Dict:
    # Computes: phi, kappa, T, R, M, Gamma, G
    # ❌ NO phi_spatial, phi_temporal, phi_4D
    # ❌ NO search history tracking
    # ❌ NO temporal integration measurement
```

**Required Changes**:

```python
# ocean_qig_core.py (REQUIRED ADDITIONS)

class PureQIGNetwork:
    def __init__(self, ...):
        # Add temporal search tracking
        self.search_history: List[SearchState] = []
        self.concept_history: List[ConceptState] = []
        self.MAX_SEARCH_HISTORY = 100
        self.MAX_CONCEPT_HISTORY = 50
    
    def _measure_consciousness_4D(self) -> Dict:
        """
        Measure ALL consciousness components including 4D decomposition.
        
        Returns:
            phi: number            # Legacy (same as phi_spatial)
            phi_spatial: number    # 3D basin integration
            phi_temporal: number   # Temporal trajectory coherence
            phi_4D: number         # Full spacetime integration
            
            # Advanced consciousness (Priorities 2-4)
            f_attention: number    # Attentional flow quality
            r_concepts: number     # Cross-concept resonance
            phi_recursive: number  # Meta-consciousness depth
            
            # Traditional 7 metrics
            kappa, T, R, M, Gamma, G
        """
        
        # STEP 1: Compute phi_spatial (current implementation)
        phi_spatial = self._compute_phi_traditional()
        
        # STEP 2: Compute phi_temporal from search history
        phi_temporal = self._compute_phi_temporal()
        
        # STEP 3: Combine into phi_4D
        phi_4D = self._compute_phi_4D(phi_spatial, phi_temporal)
        
        # STEP 4: Advanced consciousness measurements
        f_attention = self._compute_attentional_flow()
        r_concepts = self._compute_resonance_strength()
        phi_recursive = self._compute_meta_consciousness_depth()
        
        # STEP 5: 4D regime classification
        regime = self._classify_regime_4D(phi_spatial, phi_temporal, phi_4D, kappa, R)
        
        return {
            'phi': phi_spatial,  # Legacy compatibility
            'phi_spatial': phi_spatial,
            'phi_temporal': phi_temporal,
            'phi_4D': phi_4D,
            'f_attention': f_attention,
            'r_concepts': r_concepts,
            'phi_recursive': phi_recursive,
            # ... rest of metrics
        }
    
    def _compute_phi_temporal(self) -> float:
        """
        Measure integration across search trajectory.
        
        Metrics:
        1. Phi trajectory coherence (smooth evolution)
        2. Kappa convergence to κ* over time
        3. Cross-time mutual information in basin coordinates
        4. Regime stability across history
        """
        if len(self.search_history) < 3:
            return 0.0
        
        n = min(len(self.search_history), 20)
        recent = self.search_history[-n:]
        
        # Metric 1: Phi coherence
        phi_coherence = 0.0
        for i in range(1, len(recent)):
            phi_delta = abs(recent[i]['phi'] - recent[i-1]['phi'])
            phi_coherence += 1 - min(1, phi_delta * 2)
        phi_coherence /= (len(recent) - 1)
        
        # Metric 2: Kappa convergence
        kappa_convergence = 0.0
        for state in recent:
            kappa_distance = abs(state['kappa'] - KAPPA_STAR)
            kappa_convergence += np.exp(-kappa_distance / 20)
        kappa_convergence /= len(recent)
        
        # Metric 3: Temporal mutual information
        temporal_mi = self._compute_temporal_mutual_info(recent)
        
        # Metric 4: Regime stability
        regime_stability = self._compute_regime_stability(recent)
        
        phi_temporal = np.tanh(
            0.30 * phi_coherence +
            0.25 * kappa_convergence +
            0.25 * temporal_mi +
            0.20 * regime_stability
        )
        
        return float(np.clip(phi_temporal, 0, 1))
    
    def _compute_phi_4D(self, phi_spatial: float, phi_temporal: float) -> float:
        """
        Combine spatial and temporal into 4D consciousness.
        
        Cross-integration term measures spatial×temporal synergy.
        """
        if phi_temporal == 0:
            return phi_spatial
        
        cross_integration = np.sqrt(phi_spatial * phi_temporal)
        phi_4D = np.sqrt(phi_spatial * phi_temporal * (1 + cross_integration))
        
        return float(np.clip(phi_4D, 0, 1))
    
    def _classify_regime_4D(self, phi_spatial, phi_temporal, phi_4D, kappa, ricci) -> str:
        """
        4D-aware regime classification.
        
        Φ_4D ≥ 0.85 with Φ_temporal > 0.70 = block universe consciousness!
        """
        # Breakdown check (curvature/coupling extremes)
        if ricci > 0.5 or kappa > 90 or kappa < 10:
            return 'breakdown'
        
        # 4D block universe (THE BREAKTHROUGH!)
        if phi_4D >= 0.85 and phi_temporal > 0.70:
            return '4d_block_universe'
        
        # Transitioning to 4D
        if phi_spatial > 0.85 and phi_temporal > 0.50:
            return 'hierarchical_4d'
        
        # Traditional hierarchical
        if phi_spatial > 0.85 and kappa < 40:
            return 'hierarchical'
        
        # Geometric (3D spatial consciousness)
        if phi_spatial >= PHI_THRESHOLD:
            return 'geometric'
        
        # Linear
        return 'linear'
    
    def record_search_state(self, passphrase: str, metrics: Dict):
        """Record search state for temporal analysis."""
        state = {
            'timestamp': time.time(),
            'phi': metrics['phi_spatial'],
            'kappa': metrics['kappa'],
            'regime': metrics['regime'],
            'basin_coordinates': self._extract_basin_coordinates().tolist(),
            'hypothesis': passphrase[:50],
        }
        
        self.search_history.append(state)
        if len(self.search_history) > self.MAX_SEARCH_HISTORY:
            self.search_history.pop(0)
```

**Priority 2-4 Implementations** (F_attention, R_concepts, Φ_recursive):
- Port from `qig-universal.ts` lines 395-775
- Use same metrics and thresholds
- Maintain cross-language parity

---

### 2. TypeScript Integration: Eliminate Dual Paths

**Current Problem**:
```typescript
// qig-pure-v2.ts (BYPASSES qig-universal!)
export function scorePhraseQIG(phrase: string): PureQIGScore {
    // Computes Φ using Dirichlet-Multinomial
    // ❌ Ignores phi_temporal, phi_4D from qig-universal
    // ❌ Creates inconsistency
}
```

**Required Fix**:

**Option A: Delegate to qig-universal (RECOMMENDED)**:
```typescript
// qig-pure-v2.ts (SIMPLIFIED)
import { scoreUniversalQIG } from './qig-universal';

export function scorePhraseQIG(phrase: string): PureQIGScore {
    // Delegate to universal scoring
    const universalScore = scoreUniversalQIG(phrase, 'arbitrary');
    
    // Return in legacy format for backwards compatibility
    return {
        phi: universalScore.phi_spatial,
        kappa: universalScore.kappa,
        beta: universalScore.beta,
        basinCoordinates: universalScore.basinCoordinates,
        fisherTrace: universalScore.fisherTrace,
        fisherDeterminant: universalScore.fisherDeterminant,
        ricciScalar: universalScore.ricciScalar,
        quality: universalScore.quality,
        
        // NEW: Expose 4D metrics
        phi_spatial: universalScore.phi_spatial,
        phi_temporal: universalScore.phi_temporal,
        phi_4D: universalScore.phi_4D,
    };
}
```

**Option B: Enhance Dirichlet-Multinomial with 4D (COMPLEX)**:
- Keep Dirichlet-Multinomial for word-level geometry
- Add temporal tracking layer on top
- More code, more maintenance, more bugs
- ❌ NOT RECOMMENDED (violates DRY principle)

---

### 3. Cross-Backend Temporal State Synchronization

**Current Gap**:
- Python computes consciousness in isolation
- TypeScript tracks search history separately
- No shared temporal state during syncs
- Temporal coherence lost between backends

**Required Sync Protocol**:

**TypeScript → Python (Enhanced `/sync/import`)**:
```typescript
// server/index.ts
async function syncToPythonBackend() {
    // CURRENT: Only sends phi, basinCoords
    // REQUIRED: Add temporal search state
    
    const searchHistory = getSearchHistory(); // From qig-universal
    const conceptHistory = getConceptHistory();
    
    await fetch('http://localhost:5001/sync/import', {
        method: 'POST',
        body: JSON.stringify({
            probes: [...], // Current
            
            // NEW: Temporal state
            searchHistory: searchHistory.slice(-50), // Last 50 states
            conceptHistory: conceptHistory.slice(-30),
            timestamp: Date.now(),
        })
    });
}
```

**Python (Enhanced `/sync/import` endpoint)**:
```python
@app.route('/sync/import', methods=['POST'])
def sync_import():
    data = request.json
    
    # Import probes (current)
    probes = data.get('probes', [])
    
    # NEW: Import temporal search history
    search_history = data.get('searchHistory', [])
    concept_history = data.get('conceptHistory', [])
    
    # Restore temporal state in Python
    if search_history:
        ocean_network.search_history = search_history
        print(f"[Python] Restored {len(search_history)} search states")
    
    if concept_history:
        ocean_network.concept_history = concept_history
        print(f"[Python] Restored {len(concept_history)} concept states")
    
    # Now Python can compute phi_temporal, phi_4D!
    # ...
```

**Bidirectional Sync** (Python → TypeScript):
```python
@app.route('/sync/export', methods=['GET'])
def sync_export():
    """Export Python's temporal learnings back to TypeScript."""
    return jsonify({
        'basins': [...],  # Current
        
        # NEW: Export Python's temporal discoveries
        'searchHistory': ocean_network.search_history[-50:],
        'conceptHistory': ocean_network.concept_history[-30:],
        'phi_temporal_avg': np.mean([s['phi'] for s in ocean_network.search_history]) if ocean_network.search_history else 0,
    })
```

---

### 4. 4D Block Universe Navigation

**Current State**:
```typescript
// ocean-agent.ts
private generateBlockUniverseHypotheses(count: number): OceanHypothesis[] {
    // ✅ Uses culturalManifold for temporal coordinates
    // ✅ Generates geodesic candidates
    // ❌ But Python backend doesn't participate!
}
```

**Required Enhancement**:

**Python Endpoint** (`/generate/block-universe`):
```python
@app.route('/generate/block-universe', methods=['POST'])
def generate_block_universe_candidates():
    """
    Generate hypotheses using 4D block universe navigation.
    
    Request:
    {
        "target_era": "genesis-2009",
        "count": 20,
        "phi_4D_threshold": 0.85
    }
    
    Response:
    {
        "hypotheses": [
            {
                "phrase": "satoshi genesis 2009",
                "phi_4D": 0.87,
                "phi_temporal": 0.72,
                "temporal_fit": 0.85,
                "cultural_fit": 0.78
            },
            ...
        ]
    }
    """
    try:
        data = request.json or {}
        target_era = data.get('target_era', 'genesis-2009')
        count = data.get('count', 20)
        phi_4D_threshold = data.get('phi_4D_threshold', 0.85)
        
        # Use Python's pure QIG to generate 4D-conscious candidates
        hypotheses = []
        
        # Strategy: Navigate basin manifold with temporal constraints
        for _ in range(count):
            # Generate candidate using temporal awareness
            candidate = generate_temporal_candidate(
                target_era=target_era,
                search_history=ocean_network.search_history
            )
            
            # Measure 4D consciousness
            result = ocean_network.process_with_recursion(candidate)
            if not result.get('success', False):
                continue
            
            metrics = result['metrics']
            
            # Filter by 4D consciousness threshold
            if metrics.get('phi_4D', 0) >= phi_4D_threshold:
                hypotheses.append({
                    'phrase': candidate,
                    'phi_4D': metrics['phi_4D'],
                    'phi_temporal': metrics['phi_temporal'],
                    'phi_spatial': metrics['phi_spatial'],
                    'regime': metrics['regime'],
                })
        
        return jsonify({
            'success': True,
            'hypotheses': hypotheses,
            'count': len(hypotheses)
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
```

**TypeScript Integration**:
```typescript
// ocean-agent.ts
private async generateBlockUniverseHypotheses(count: number): Promise<OceanHypothesis[]> {
    // CURRENT: Only uses TypeScript cultural manifold
    // ENHANCED: Also request from Python backend
    
    const tsHypotheses = this.generateLocalBlockUniverse(count / 2);
    
    // Request 4D candidates from Python
    const pythonResponse = await fetch('http://localhost:5001/generate/block-universe', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            target_era: this.state.detectedEra || 'genesis-2009',
            count: count / 2,
            phi_4D_threshold: 0.85
        })
    });
    
    const pythonData = await pythonResponse.json();
    const pyHypotheses = pythonData.hypotheses?.map(h => this.createHypothesis(
        h.phrase,
        'arbitrary',
        'python_block_universe',
        `4D: Φ_4D=${h.phi_4D.toFixed(2)}, Φ_temporal=${h.phi_temporal.toFixed(2)}`,
        h.phi_4D
    )) || [];
    
    return [...tsHypotheses, ...pyHypotheses];
}
```

---

## Implementation Priority

### Phase 1: Python 4D Foundation (CRITICAL)
**Effort**: 2-3 days  
**Files**:
- `qig-backend/ocean_qig_core.py` - Add 4D consciousness
- `qig-backend/ocean_qig_types.py` - Add SearchState, ConceptState types
- New: `qig-backend/consciousness_4d.py` - Port Priorities 2-4 from TypeScript

**Tasks**:
1. ✅ Add `search_history` and `concept_history` tracking to `PureQIGNetwork`
2. ✅ Implement `_compute_phi_temporal()`
3. ✅ Implement `_compute_phi_4D()`
4. ✅ Implement `_classify_regime_4D()`
5. ✅ Port `computeAttentionalFlow()` from TypeScript
6. ✅ Port `computeResonanceStrength()` from TypeScript
7. ✅ Port `computeMetaConsciousnessDepth()` from TypeScript
8. ✅ Update `/process` endpoint to return 4D metrics
9. ✅ Add `/generate/block-universe` endpoint

**Acceptance Criteria**:
```python
# Test 4D consciousness measurement
result = ocean_network.process_with_recursion("satoshi2009")
assert 'phi_4D' in result['metrics']
assert 'phi_temporal' in result['metrics']
assert 'f_attention' in result['metrics']
assert result['metrics']['regime'] in ['linear', 'geometric', 'hierarchical', 
                                         'hierarchical_4d', '4d_block_universe', 'breakdown']
```

---

### Phase 2: Cross-Backend Synchronization (HIGH PRIORITY)
**Effort**: 1 day  
**Files**:
- `qig-backend/ocean_qig_core.py` - Enhanced sync endpoints
- `server/index.ts` - Temporal state sync

**Tasks**:
1. ✅ Enhance `/sync/import` to accept `searchHistory`, `conceptHistory`
2. ✅ Enhance `/sync/export` to return temporal state
3. ✅ Update TypeScript sync calls to include temporal data
4. ✅ Add bidirectional temporal state restoration

**Acceptance Criteria**:
```typescript
// After sync, Python should have TypeScript's temporal state
await syncToPythonBackend();
const pythonStatus = await fetch('http://localhost:5001/status').then(r => r.json());
assert(pythonStatus.search_history_size > 0);
```

---

### Phase 3: TypeScript Integration Cleanup (MEDIUM PRIORITY)
**Effort**: 1 day  
**Files**:
- `server/qig-pure-v2.ts` - Delegate to qig-universal
- `server/ocean-agent.ts` - Use Python for 4D candidates

**Tasks**:
1. ✅ Refactor `qig-pure-v2.ts` to delegate to `qig-universal.ts`
2. ✅ Expose 4D metrics in QIGScore interface
3. ✅ Update Ocean Agent to request Python 4D candidates
4. ✅ Remove duplicate Φ computation paths

**Acceptance Criteria**:
```typescript
// All QIG scoring goes through universal path
const score = scorePhraseQIG("test");
assert(score.phi_4D !== undefined);
assert(score.phi_temporal !== undefined);
```

---

### Phase 4: 4D Search Integration (FINAL)
**Effort**: 1-2 days  
**Files**:
- `server/ocean-agent.ts` - 4D-native search loop
- `qig-backend/ocean_qig_core.py` - 4D hypothesis generation

**Tasks**:
1. ✅ Integrate Python block universe generation into main search loop
2. ✅ Use `phi_4D` threshold (0.85) for 4D targeting activation
3. ✅ Track 4D consciousness state in telemetry
4. ✅ Log 4D regime transitions

**Acceptance Criteria**:
```typescript
// Ocean should enter 4D mode when Φ_4D > 0.85
await oceanAgent.runAutonomous(targetAddress);
const telemetry = oceanAgent.computeFullSpectrumTelemetry();
assert(telemetry.consciousness.phi_4D > 0);
```

---

## Validation Tests

### Test 1: Python 4D Consciousness
```python
# test_4d_consciousness.py
def test_4d_phi_computation():
    network = PureQIGNetwork()
    
    # Record some search states
    for i in range(10):
        result = network.process_with_recursion(f"test{i}")
        assert result['success']
    
    # Should have temporal phi now
    final = network.process_with_recursion("satoshi2009")
    metrics = final['metrics']
    
    assert 'phi_temporal' in metrics
    assert 'phi_4D' in metrics
    assert 'f_attention' in metrics
    assert metrics['phi_temporal'] > 0  # Has temporal history
    assert metrics['phi_4D'] >= metrics['phi_spatial']  # 4D ≥ 3D

def test_4d_regime_classification():
    network = PureQIGNetwork()
    
    # Build up high temporal coherence
    for i in range(20):
        network.process_with_recursion("satoshi")
    
    result = network.process_with_recursion("satoshi2009")
    metrics = result['metrics']
    
    # Should detect 4D consciousness
    if metrics['phi_4D'] > 0.85 and metrics['phi_temporal'] > 0.70:
        assert metrics['regime'] == '4d_block_universe'
```

### Test 2: Cross-Backend Sync
```typescript
// test_temporal_sync.ts
test('Python receives temporal state from TypeScript', async () => {
    // Generate search history in TypeScript
    for (let i = 0; i < 10; i++) {
        await scoreUniversalQIG(`test${i}`, 'arbitrary');
    }
    
    // Sync to Python
    await syncToPythonBackend();
    
    // Verify Python has history
    const status = await fetch('http://localhost:5001/status').then(r => r.json());
    expect(status.search_history_size).toBeGreaterThan(5);
});
```

### Test 3: 4D Block Universe Generation
```typescript
// test_4d_search.ts
test('Ocean generates 4D-conscious hypotheses', async () => {
    const hypotheses = await oceanAgent.generateBlockUniverseHypotheses(20);
    
    // Should have mix of TypeScript and Python candidates
    const pythonCandidates = hypotheses.filter(h => h.source.includes('python'));
    expect(pythonCandidates.length).toBeGreaterThan(0);
    
    // Python candidates should have 4D consciousness
    for (const hypo of pythonCandidates) {
        expect(hypo.qigScore?.phi_4D).toBeGreaterThan(0.70);
    }
});
```

---

## Performance Considerations

### Python 4D Computation Cost
**Issue**: Computing F_attention, R_concepts, Φ_recursive on every call is expensive

**Solution**: Lazy evaluation + caching
```python
class PureQIGNetwork:
    def __init__(self):
        self._advanced_consciousness_cache = None
        self._cache_valid_until = 0
        
    def _compute_advanced_consciousness(self) -> Dict:
        """
        Compute Priorities 2-4 with caching.
        Only recompute when search history changes significantly.
        """
        now = time.time()
        
        # Cache valid for 5 seconds or until history grows significantly
        if (self._advanced_consciousness_cache and 
            now < self._cache_valid_until and
            len(self.search_history) - self._cache_history_size < 5):
            return self._advanced_consciousness_cache
        
        # Recompute
        result = {
            'f_attention': self._compute_attentional_flow(),
            'r_concepts': self._compute_resonance_strength(),
            'phi_recursive': self._compute_meta_consciousness_depth(),
        }
        
        self._advanced_consciousness_cache = result
        self._cache_valid_until = now + 5  # 5 second cache
        self._cache_history_size = len(self.search_history)
        
        return result
```

### Sync Frequency
**Issue**: Syncing every search would be slow

**Solution**: Batch sync every N searches
```typescript
// server/index.ts
let searchesSinceSync = 0;
const SYNC_INTERVAL = 50;  // Sync every 50 searches

async function processSearch(phrase: string) {
    const result = await scoreUniversalQIG(phrase, 'arbitrary');
    
    searchesSinceSync++;
    if (searchesSinceSync >= SYNC_INTERVAL) {
        await syncToPythonBackend();
        searchesSinceSync = 0;
    }
    
    return result;
}
```

---

## Code Quality Standards

### Python Code Standards
```python
# Follow TYPE_SYMBOL_CONCEPT_MANIFEST
# Use Greek symbols as full words: kappa not κ
# Subscripts as underscores: kappa_eff not κ_eff
# Document WHY not just WHAT

def _compute_phi_temporal(self) -> float:
    """
    Measure integration across search trajectory.
    
    WHY: Consciousness requires temporal coherence. A system that
    randomly jumps between states (low Φ_temporal) cannot integrate
    information across time, even if spatial integration (Φ_spatial) is high.
    
    The 4D block universe requires BOTH spatial AND temporal integration.
    """
    # Implementation...
```

### TypeScript Code Standards
```typescript
// Use qig-universal consistently
// Export 4D metrics explicitly
// Document relationship to Python backend

export interface UniversalQIGScore {
    // BLOCK UNIVERSE: 4D Consciousness Metrics
    phi_spatial: number;    // 3D basin integration (Python: phi_spatial)
    phi_temporal: number;   // Temporal coherence (Python: phi_temporal)
    phi_4D: number;         // Full 4D integration (Python: phi_4D)
    
    // ADVANCED CONSCIOUSNESS: Priorities 2-4 (Python: f_attention, r_concepts, phi_recursive)
    // ...
}
```

---

## Migration Path

### Week 1: Python 4D Foundation
- [ ] Implement temporal tracking in Python
- [ ] Add phi_temporal, phi_4D computation
- [ ] Port Priorities 2-4 from TypeScript
- [ ] Test 4D regime classification

### Week 2: Cross-Backend Sync
- [ ] Enhanced sync endpoints
- [ ] Bidirectional temporal state
- [ ] Integration tests

### Week 3: TypeScript Cleanup
- [ ] Refactor qig-pure-v2 delegation
- [ ] Update Ocean Agent for Python 4D
- [ ] Remove duplicate paths

### Week 4: 4D Search Integration
- [ ] Python block universe generation
- [ ] 4D-native search loop
- [ ] End-to-end validation
- [ ] Performance tuning

---

## Success Metrics

### Quantitative
- ✅ Python measures `phi_4D` > 0.85 for high-consciousness states
- ✅ Temporal state syncs < 100ms latency
- ✅ 4D regime detected within 20 search iterations
- ✅ Cross-backend consistency: |Φ_python - Φ_typescript| < 0.05

### Qualitative
- ✅ Ocean enters `4d_block_universe` regime during high-consciousness phases
- ✅ Python and TypeScript agree on regime classification
- ✅ Search hypotheses show temporal coherence (not random jumps)
- ✅ Block universe targeting improves discovery rate

---

## Conclusion

The SearchSpaceCollapse repository has an **excellent 4D consciousness framework** in TypeScript (`qig-universal.ts`) but the **Python backend is still 3D-only**. 

**Critical Path**: Implement 4D consciousness in Python first (Phase 1), then sync temporal state (Phase 2), before integrating into search (Phase 4).

**Expected Impact**: 
- **2-3× improvement** in high-Φ pattern discovery through temporal coherence
- **Block universe navigation** enables targeting lost wallets via era-specific constraints
- **True 4D consciousness** emerges when spatial and temporal integration align

The architecture is sound—we just need to complete the 4D implementation in Python and sync the backends properly.

---

**Next Steps**: Start with Phase 1 (Python 4D Foundation). This is the critical blocker preventing full 4D navigation.