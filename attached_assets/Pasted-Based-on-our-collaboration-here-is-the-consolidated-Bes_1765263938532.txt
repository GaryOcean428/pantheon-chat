Based on our collaboration, here is the consolidated **Best Practice Manifesto** for the `searchspacecollapse` / `qig-consciousness` ecosystem.

These standards are designed to keep the hybrid Node.js/Python architecture scalable, secure, and maintainable.

---

### 1. Architecture & Organization

#### **The "Barrel" Pattern (Clean Imports)**
* **Concept:** Every functional folder (components, hooks, services) must have an `index.ts` file that re-exports its contents.
* **Rule:** Never import from deep paths if a barrel exists.
* **Example:**
    * **Bad:** `import { Button } from '@/components/ui/button';`
    * **Good:** `import { Button } from '@/components/ui';`

#### **Hybrid Monorepo Structure**
* **Separation:**
    * **Node.js (`server/`)**: Acts as the **Orchestrator/API Gateway**. It handles auth, routing, and high-frequency state.
    * **Python (`qig-backend/`)**: Acts as the **Cognitive Engine**. It handles heavy compute, geometry, and autonomous loops.
* **Rule:** Node.js should never perform heavy math; it delegates to Python. Python should never handle user auth; it trusts Node.js.

---

### 2. Centralized API Management

#### **The "Route Registry" (No Magic Strings)**
* **Concept:** All API URL paths must be defined in a single file (`client/src/api/routes.ts`).
* **Rule:** UI components must never contain hardcoded strings like `"/api/olympus/status"`.
* **Benefit:** If an endpoint changes, you update it in **one place**, and the whole app updates.

#### **The Service Layer Pattern**
* **Concept:** Wrap all API calls in typed functions (e.g., `OlympusService.getShadowStatus()`).
* **Rule:** View components (`.tsx`) must never call `fetch` or `axios` directly. They calls **Services**, which call the **Registry**, which uses the **Singleton Client**.
* **Stack:** `React Component` $\rightarrow$ `Custom Hook` $\rightarrow$ `Service Layer` $\rightarrow$ `API Client`.

---

### 3. DRY (Don't Repeat Yourself) & Truth

#### **Single Source of Truth (Types & Constants)**
* **Types:** Define interfaces in `shared/types/`. Both Frontend and Backend import from here.
    * *Strictness:* If the Database schema changes, the Frontend build should fail.
* **Constants:** Physics constants ($\Phi$, $\kappa$) live in `shared/constants/`. Use scripts (`export-constants-to-python.ts`) to generate the Python equivalents during build time to ensure the "Brain" and "Body" obey the same laws of physics.

#### **Persistence Facade**
* **Problem:** Switching between JSON files (dev) and PostgreSQL (prod) creates duplicate logic.
* **Solution:** Use a **Facade** (`server/persistence/facade.ts`).
* **Rule:** The application logic calls `persistence.save()`. It does **not** know if that saves to a file or a database row.

---

### 4. Component Engineering

#### **The "Hook/View" Split**
* **Concept:** Separate **Logic** (State, Effects, Polling) from **Rendering** (JSX).
* **Rule:** If a component has more than 2 `useEffect` hooks, extract the logic into a custom hook (e.g., `useZeusChat.ts`).
* **Benefit:** The UI becomes purely presentational and easier to test.

#### **Sanity Limits**
* **Rule:** Don't block users with arbitrary limits (like 400 chars). Use "Sanity Limits" (e.g., 10,000 chars) to prevent browser crashes, but allow "God Mode" context.

---

### 5. Operational Resilience

#### **Circuit Breakers & Retries**
* **Context:** Node.js talking to Python is a network call. It *will* fail.
* **Rule:** Wrap internal calls in a **Circuit Breaker**. If Python crashes 5 times, stop calling it for 60 seconds to let it recover.
* **Handling:** Handle `503 Service Unavailable` with **Exponential Backoff** (wait 1s, then 2s, then 4s).

#### **Death Spiral Prevention**
* **Rule:** When spawning subprocesses (like the Python Kernel), enforce a **Restart Limit** (e.g., max 5 restarts in 1 minute). If it keeps dying, log a critical error and stop trying, rather than consuming 100% CPU in an infinite restart loop.

---

### 6. Documentation Compliance (ISO 27001)

* **Structure:** Explicit folders for `01-policies` (Rules), `02-procedures` (How-To), and `04-records` (Evidence).
* **Versioning:** Every document must have YAML frontmatter tracking `version`, `owner`, and `last_reviewed_date`.
* **Immutable History:** Decisions are tracked in **ADRs** (Architecture Decision Records) in `docs/05-decisions/`. We don't just change code; we record *why* we changed it.