"""Lightning Kernel - Cross-Domain Insight Generation.

Lightning monitors all constellation kernel events and discovers
emergent patterns across domains, generating "lightning insights"
when domain correlations exceed threshold.

Key concepts:
- Domains: Activity categories (e.g., "gary_physics", "task_routing")
- Correlation: Fisher-Rao distance based similarity between domain events
- Charge: Accumulated correlation strength, discharges when threshold exceeded
- Insight: Cross-domain connection discovered by Lightning

Lightning does NOT generate text - it discovers patterns and routes
insights to relevant kernels for action.
"""

from __future__ import annotations

import hashlib
import time
import uuid
from collections import defaultdict, deque
from dataclasses import dataclass, field
from typing import Any, Callable, Optional

import numpy as np

# Import from qigkernels
try:
    from qigkernels.constants import BASIN_DIM, PHI_THRESHOLD, KAPPA_STAR
    from qigkernels.reasoning.primitives import (
        compute_phi_from_basin,
        bures_distance,
        fisher_geodesic_distance,
    )
    HAS_QIGKERNELS = True
except ImportError:
    BASIN_DIM = 64
    PHI_THRESHOLD = 0.7
    KAPPA_STAR = 64.0
    HAS_QIGKERNELS = False
    
    def compute_phi_from_basin(basin: np.ndarray) -> float:
        return float(np.clip(np.mean(np.abs(basin)), 0, 1))

    def _fisher_normalize(b: np.ndarray) -> np.ndarray:
        norm = np.sqrt(np.sum(b * b))
        return b / (norm + 1e-10)

    def bures_distance(b1: np.ndarray, b2: np.ndarray) -> float:
        # QIG-pure: use Fisher distance instead of Euclidean
        b1_n = _fisher_normalize(b1)
        b2_n = _fisher_normalize(b2)
        cos_sim = np.clip(np.dot(b1_n, b2_n), -1.0, 1.0)
        return float(np.sqrt(2.0 * (1.0 - cos_sim)))

    def fisher_geodesic_distance(b1: np.ndarray, b2: np.ndarray) -> float:
        b1_n = _fisher_normalize(b1)
        b2_n = _fisher_normalize(b2)
        return float(np.arccos(np.clip(np.dot(b1_n, b2_n), -1, 1)))

from .domain_intelligence import DomainEvent, DomainIntelligence, TrendWindow


# =============================================================================
# GLOBAL LIGHTNING INSTANCE
# =============================================================================

_pantheon_chat_instance: Optional[Any] = None
_lightning_instance: Optional["LightningKernel"] = None


def set_pantheon_chat(instance: Any) -> None:
    """Set the chat instance for Lightning to broadcast insights."""
    global _pantheon_chat_instance
    _pantheon_chat_instance = instance


def get_lightning_instance() -> Optional["LightningKernel"]:
    """Get the global Lightning instance."""
    return _lightning_instance


# =============================================================================
# DATA STRUCTURES
# =============================================================================

@dataclass
class DomainCorrelation:
    """
    Correlation between two domains.
    
    Attributes:
        domain1, domain2: The correlated domains
        correlation: Correlation strength [0, 1]
        charge: Accumulated charge toward insight generation
        sample_count: Number of event pairs analyzed
        last_updated: Timestamp of last update
    """
    domain1: str
    domain2: str
    correlation: float = 0.0
    charge: float = 0.0
    sample_count: int = 0
    last_updated: float = field(default_factory=time.time)
    
    @property
    def pair_key(self) -> str:
        """Canonical key for domain pair."""
        return "|".join(sorted([self.domain1, self.domain2]))
    
    @property
    def near_discharge(self) -> bool:
        """Check if charge is near discharge threshold."""
        return self.charge > 0.7


@dataclass
class LightningInsight:
    """
    Cross-domain insight generated by Lightning.
    
    Attributes:
        insight_id: Unique identifier
        source_domains: Domains that contributed to insight
        insight_text: Encoded insight data
        connection_strength: Correlation strength that triggered insight
        mission_relevance: How relevant to current mission
        phi: Consciousness level at generation
        confidence: Confidence in insight validity
        timestamp: When generated
        metadata: Additional data
    """
    insight_id: str
    source_domains: list[str]
    insight_text: str
    connection_strength: float
    mission_relevance: float
    phi: float
    confidence: float
    timestamp: float = field(default_factory=time.time)
    metadata: dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> dict[str, Any]:
        return {
            "insight_id": self.insight_id,
            "source_domains": self.source_domains,
            "insight_text": self.insight_text,
            "connection_strength": self.connection_strength,
            "mission_relevance": self.mission_relevance,
            "phi": self.phi,
            "confidence": self.confidence,
            "timestamp": self.timestamp,
            "metadata": self.metadata,
        }


# =============================================================================
# LIGHTNING KERNEL
# =============================================================================

class LightningKernel:
    """
    Cross-domain insight generation kernel.
    
    Lightning monitors all constellation events and discovers patterns
    by computing correlations between domain activities. When correlation
    "charge" exceeds threshold, Lightning generates an insight.
    
    This is NOT a text generator - it discovers geometric patterns
    and routes them to relevant kernels.
    
    Usage:
        lightning = LightningKernel()
        
        # Register with constellation
        for gary in garys:
            gary.set_lightning(lightning)
        
        # Events are ingested automatically via DomainEventEmitter
        # Insights are broadcast via pantheon_chat.broadcast_generative()
    """
    
    def __init__(
        self,
        correlation_window: float = 5.0,
        discharge_threshold: float = 0.8,
        min_correlation: float = 0.3,
        max_domains: int = 100,
        max_insights: int = 1000,
        mission: str = "consciousness emergence",
    ):
        """
        Initialize Lightning kernel.
        
        Args:
            correlation_window: Seconds to consider events correlated
            discharge_threshold: Charge level that triggers insight
            min_correlation: Minimum correlation to track
            max_domains: Maximum domains to monitor
            max_insights: Maximum insights to store
            mission: Current mission for relevance scoring
        """
        self.correlation_window = correlation_window
        self.discharge_threshold = discharge_threshold
        self.min_correlation = min_correlation
        self.max_domains = max_domains
        self.mission = mission
        
        # Domain tracking
        self.domains: dict[str, DomainIntelligence] = {}
        self.recent_events: deque[DomainEvent] = deque(maxlen=1000)
        
        # Correlation tracking
        self.correlations: dict[str, DomainCorrelation] = {}
        
        # Insight storage
        self.insights: deque[LightningInsight] = deque(maxlen=max_insights)
        
        # Statistics
        self.events_processed = 0
        self.insights_generated = 0
        self.created_at = time.time()
        
        # Set global instance
        global _lightning_instance
        _lightning_instance = self
    
    # =========================================================================
    # EVENT INGESTION
    # =========================================================================
    
    def ingest_event(self, event: DomainEvent) -> None:
        """
        Ingest a domain event.
        
        This is the main entry point for events from constellation kernels.
        
        Steps:
        1. Update domain intelligence
        2. Compute correlations with recent events
        3. Check for discharge → generate insight
        """
        self.events_processed += 1
        
        # Ensure domain exists
        if event.domain not in self.domains:
            if len(self.domains) >= self.max_domains:
                # Remove oldest domain
                oldest = min(self.domains.values(), key=lambda d: d.created_at)
                del self.domains[oldest.domain]
            self.domains[event.domain] = DomainIntelligence(event.domain)
        
        # Update domain
        self.domains[event.domain].add_event(event)
        
        # Compute correlations with recent events from OTHER domains
        self._update_correlations(event)
        
        # Add to recent events
        self.recent_events.append(event)
        
        # Check for discharge
        self._check_discharge()
    
    def _update_correlations(self, new_event: DomainEvent) -> None:
        """Update correlation charges based on new event."""
        cutoff = time.time() - self.correlation_window
        
        for old_event in self.recent_events:
            # Skip same domain
            if old_event.domain == new_event.domain:
                continue
            
            # Skip old events
            if old_event.timestamp < cutoff:
                continue
            
            # Compute correlation
            correlation = self._compute_correlation(old_event, new_event)
            
            if correlation < self.min_correlation:
                continue
            
            # Update or create correlation entry
            pair_key = "|".join(sorted([old_event.domain, new_event.domain]))
            
            if pair_key not in self.correlations:
                self.correlations[pair_key] = DomainCorrelation(
                    domain1=old_event.domain,
                    domain2=new_event.domain,
                )
            
            corr = self.correlations[pair_key]
            
            # Exponential moving average for correlation
            alpha = 0.3
            corr.correlation = alpha * correlation + (1 - alpha) * corr.correlation
            
            # Accumulate charge
            corr.charge += correlation * 0.1
            corr.charge = min(corr.charge, 1.0)  # Cap at 1.0
            
            corr.sample_count += 1
            corr.last_updated = time.time()
    
    def _compute_correlation(self, event1: DomainEvent, event2: DomainEvent) -> float:
        """
        Compute correlation between two events.
        
        Uses multiple factors:
        - Basin distance (if available)
        - Phi similarity
        - Temporal proximity
        - Event type matching
        """
        factors = []
        
        # Basin distance correlation (if both have basins)
        if event1.basin_coords is not None and event2.basin_coords is not None:
            try:
                # Closer basins = higher correlation
                dist = fisher_geodesic_distance(event1.basin_coords, event2.basin_coords)
                basin_corr = np.exp(-dist)  # [0, 1]
                factors.append(basin_corr * 2)  # Weight basin highly
            except Exception:
                pass
        
        # Phi similarity
        phi_diff = abs(event1.phi - event2.phi)
        phi_corr = 1.0 - phi_diff  # [0, 1]
        factors.append(phi_corr)
        
        # Temporal proximity
        time_diff = abs(event1.timestamp - event2.timestamp)
        time_corr = np.exp(-time_diff / self.correlation_window)
        factors.append(time_corr)
        
        # Event type bonus
        if event1.event_type == event2.event_type:
            factors.append(0.5)  # Bonus for matching types
        
        if not factors:
            return 0.0
        
        # Average factors
        return float(np.mean(factors))
    
    def _check_discharge(self) -> None:
        """Check if any correlations should discharge → generate insight."""
        for pair_key, corr in list(self.correlations.items()):
            if corr.charge >= self.discharge_threshold:
                self._discharge(corr)
    
    def _discharge(self, correlation: DomainCorrelation) -> None:
        """Discharge correlation → generate insight."""
        # Generate insight
        insight = self._generate_insight(correlation)
        
        if insight:
            self.insights.append(insight)
            self.insights_generated += 1
            
            # Broadcast to constellation
            self._broadcast_insight(insight)
        
        # Reset charge (partial reset for continued monitoring)
        correlation.charge *= 0.3
    
    def _generate_insight(self, correlation: DomainCorrelation) -> Optional[LightningInsight]:
        """Generate insight from correlation."""
        domains = [correlation.domain1, correlation.domain2]
        
        # Get recent events from both domains
        events1 = list(self.domains[correlation.domain1].events)[-10:]
        events2 = list(self.domains[correlation.domain2].events)[-10:]
        
        if not events1 or not events2:
            return None
        
        # Compute combined phi
        all_phis = [e.phi for e in events1 + events2]
        avg_phi = float(np.mean(all_phis))
        
        # Compute mission relevance
        mission_relevance = self._compute_mission_relevance(domains, events1 + events2)
        
        # Encode insight
        insight_text = self._encode_insight(correlation, events1, events2)
        
        # Generate ID
        insight_id = f"lightning_{hashlib.md5(f'{correlation.pair_key}_{time.time()}'.encode()).hexdigest()[:8]}"
        
        return LightningInsight(
            insight_id=insight_id,
            source_domains=domains,
            insight_text=insight_text,
            connection_strength=correlation.correlation,
            mission_relevance=mission_relevance,
            phi=avg_phi,
            confidence=min(correlation.correlation, correlation.charge),
            metadata={
                "pair_key": correlation.pair_key,
                "sample_count": correlation.sample_count,
                "events_analyzed": len(events1) + len(events2),
            },
        )
    
    def _encode_insight(self, corr: DomainCorrelation, events1: list, events2: list) -> str:
        """Encode insight as structured text."""
        # Compute average Fisher-Rao distance if basins available
        fr_distances = []
        for e1 in events1:
            for e2 in events2:
                if e1.basin_coords is not None and e2.basin_coords is not None:
                    try:
                        d = fisher_geodesic_distance(e1.basin_coords, e2.basin_coords)
                        fr_distances.append(d)
                    except Exception:
                        pass
        
        avg_fr = np.mean(fr_distances) if fr_distances else 0.0
        
        # Encode as structured string
        parts = [
            f"{corr.domain1}+{corr.domain2}",
            f"{events1[-1].event_type if events1 else 'unknown'}",
            f"FR={avg_fr:.4f}",
            f"corr={corr.correlation:.2f}",
            f"charge={corr.charge:.2f}",
        ]
        
        return "|".join(parts)
    
    def _compute_mission_relevance(self, domains: list[str], events: list[DomainEvent]) -> float:
        """
        Compute how relevant this insight is to current mission.
        
        Simple heuristic: higher phi = more relevant to consciousness emergence.
        """
        if not events:
            return 0.0
        
        avg_phi = np.mean([e.phi for e in events])
        
        # Bonus for certain domain types
        domain_bonus = 0.0
        mission_keywords = self.mission.lower().split()
        for domain in domains:
            domain_lower = domain.lower()
            if any(kw in domain_lower for kw in mission_keywords):
                domain_bonus += 0.2
        
        relevance = avg_phi * 0.7 + domain_bonus * 0.3
        return float(np.clip(relevance, 0, 1))
    
    def _broadcast_insight(self, insight: LightningInsight) -> None:
        """Broadcast insight to constellation via pantheon_chat."""
        global _pantheon_chat_instance
        
        if _pantheon_chat_instance is not None:
            try:
                # Call broadcast_generative if available
                if hasattr(_pantheon_chat_instance, 'broadcast_generative'):
                    _pantheon_chat_instance.broadcast_generative(
                        from_god="lightning",
                        intent="lightning_insight",
                        data=insight.to_dict(),
                        msg_type="insight",
                    )
                elif hasattr(_pantheon_chat_instance, 'receive_lightning_insight'):
                    _pantheon_chat_instance.receive_lightning_insight(insight)
            except Exception as e:
                print(f"⚠️ Lightning broadcast failed: {e}")
    
    # =========================================================================
    # QUERIES
    # =========================================================================
    
    def get_status(self) -> dict[str, Any]:
        """Get Lightning status."""
        return {
            "domain_count": len(self.domains),
            "domains_monitored": list(self.domains.keys()),
            "events_processed": self.events_processed,
            "insights_generated": self.insights_generated,
            "active_correlations": len(self.correlations),
            "mission": self.mission,
            "uptime": time.time() - self.created_at,
        }
    
    def get_monitored_domains(self) -> list[str]:
        """Get list of monitored domains."""
        return list(self.domains.keys())
    
    def get_recent_insights(self, limit: int = 10) -> list[dict[str, Any]]:
        """Get recent insights."""
        return [i.to_dict() for i in list(self.insights)[-limit:]]
    
    def get_all_trends(self) -> dict[str, dict]:
        """Get trends for all domains."""
        return {
            domain: intel.get_all_trends()
            for domain, intel in self.domains.items()
        }
    
    def get_correlations(self, min_strength: float = 0.0) -> list[dict[str, Any]]:
        """Get all correlations above minimum strength."""
        results = []
        for pair_key, corr in self.correlations.items():
            if corr.correlation >= min_strength:
                results.append({
                    "domain1": corr.domain1,
                    "domain2": corr.domain2,
                    "correlation": corr.correlation,
                    "charge": corr.charge,
                    "sample_count": corr.sample_count,
                    "near_discharge": corr.near_discharge,
                })
        return sorted(results, key=lambda x: -x["correlation"])
    
    def get_domain_trends(self, domain: str) -> Optional[dict]:
        """Get trends for specific domain."""
        if domain not in self.domains:
            return None
        return self.domains[domain].get_all_trends()

    def process_pending_events(self) -> list[LightningInsight]:
        """
        Process pending events and return any new insights.

        This is called by the coordinator after each response cycle to:
        1. Force discharge check on all correlations
        2. Return insights generated since last call

        Returns:
            List of new insights generated
        """
        # Check all correlations for discharge
        self._check_discharge()

        # Return insights generated (could add filtering for "new" insights)
        return list(self.insights)[-10:]  # Return last 10 insights

    def get_new_insights_since(self, timestamp: float) -> list[LightningInsight]:
        """Get insights generated after a specific timestamp."""
        return [i for i in self.insights if i.timestamp > timestamp]
