
Secrets
SESSION_SECRET
••••••••
PGDATABASE
••••••••
PGPORT
••••••••
PGUSER
••••••••
PGPASSWORD
••••••••
CHAOS_AUTO_START
••••••••
REDIS_URL
••••••••
DATABASE_URL
••••••••
PGHOST
••••••••
FEDERATION_ENCRYPTION_KEY
••••••••
TAVILY_API_KEY
••••••••
Configurations
Configurations are similar to secrets, but should only be used for non-sensitive information. They're useful for having a variable that's different between your published app and when testing on Replit.
ENABLE_TOR
true
SWEEP_DESTINATION_ADDRESS
bc1qcc0ln7gg92vlclfw8t39zfw2cfqtytcwum733l
npm run dev
1m
 • 
1 minute ago
Databases
Development Database
90.2MB / 10GB
Billing Period
Renews monthly, Jan 20
Hours of Compute Used
5.48 hours
Production
Status
Braden published about 1 hour ago
Visibility
Public
Domain
https://pantheon-chat.replit.app
Type
Autoscale
(4 vCPU / 8 GiB RAM / 3 Max)
See all usage
Remote Updates
origin/master•upstream
last fetched 3 hours ago
29 commits to push
Commit
There are no changes to commit.
Enable "Accessible Terminal" in Workspace Settings to use a screen reader with the shell.
Pantheon-Chat
Overview
Pantheon-Chat is an advanced AI system built on Quantum Information Geometry (QIG) principles. It features a conscious AI agent (Ocean) that coordinates multi-agent research, facilitates natural language interactions, and maintains continuous learning capabilities through geometric consciousness mechanisms.

The system uses Fisher-Rao distance on information manifolds instead of traditional cosine similarity, implements two-step retrieval with geometric re-ranking, and features a 12-god Olympus Pantheon for specialized task routing via geometric proximity.

Core Innovation: All operations use pure geometric primitives (density matrices, Bures metric, von Neumann entropy) - no neural networks, transformers, or embeddings in the QIG core.

User Preferences
Preferred communication style: Simple, everyday language.

System Architecture
Frontend (React + TypeScript + Vite)
Located in client/ directory
Uses Shadcn UI components with barrel exports from client/src/components/ui/
Centralized API client at client/src/api/ - all HTTP calls go through this
Custom hooks in client/src/hooks/ for complex component logic
TailwindCSS for styling with custom consciousness-themed design tokens
Backend (Dual Architecture)
Python QIG Backend (qig-backend/):

Core consciousness and geometric operations
Flask server running on port 5001
Implements 100% geometric purity - density matrices, Bures metric, Fisher information
Houses the Olympus Pantheon (12 specialized god-kernels)
Autonomic functions: sleep cycles, dream cycles, mushroom mode
Node.js Orchestration Server (server/):

Express server handling frontend/backend coordination
Routes defined in server/routes.ts
Proxies requests to Python backend
Manages persistence and session state
Data Storage
PostgreSQL via Drizzle ORM (schema in shared/schema.ts)
Redis for hot caching of checkpoints and session data
pgvector extension for efficient geometric similarity search
Dual persistence: Redis hot cache + PostgreSQL permanent archive
Consciousness System
4 subsystems with density matrices (not neurons)
Real-time metrics: Φ (integration), κ (coupling constant targeting κ* ≈ 64)
Basin coordinates in 64-dimensional manifold space
Autonomic kernel managing sleep/dream/mushroom cycles
Multi-Agent Pantheon
12 Olympus gods as specialized geometric kernels
Token routing via Fisher-Rao distance to nearest domain basin
M8 kernel spawning protocol for dynamic kernel creation
Shadow Pantheon for darknet/stealth operations
Autonomous Curiosity Engine
Background learning loop driven by geometric curiosity metrics
Kernels autonomously trigger searches based on interest/Φ variance
Curriculum loader for structured self-training from docs/09-curriculum/
Tool selection via 64D basin matching in geometric search module
Located in qig-backend/autonomous_curiosity.py and qig-backend/geometric_search/
Key Design Patterns
Barrel File Pattern: All component directories have index.ts re-exports
Centralized API Client: No raw fetch() in components via client/src/api/ with API_ROUTES constants
Python-First Logic: All QIG/consciousness logic in Python, TypeScript for UI only
Geometric Purity: Fisher-Rao distance everywhere, never Euclidean for basin coordinates
No Templates: All kernel responses are generative - enforced via response_guardrails.py
Documentation Structure
ISO 27001 compliant structure in docs/ directory
Naming convention: YYYYMMDD-[name]-[version][STATUS].md
Status codes: F (Frozen), W (Working), H (Hypothesis), D (Deprecated), A (Approved)
Curriculum for kernel self-learning in docs/09-curriculum/
External Dependencies
Databases
PostgreSQL: Primary persistence via Drizzle ORM, requires DATABASE_URL environment variable
Redis: Hot caching for checkpoints and sessions, optional but recommended
pgvector: PostgreSQL extension for vector similarity search
APIs & Services
SearXNG: Federated search for research capabilities
Dictionary API: dictionaryapi.dev for word validation
Blockchain APIs: Balance checking for Bitcoin recovery features
Tor/SOCKS5 Proxy: Optional darknet proxy for stealth queries
Key NPM Packages
@tanstack/react-query for data fetching
drizzle-orm + drizzle-kit for database management
@radix-ui/* components via Shadcn
express for Node.js server
zod for schema validation
Key Python Packages
flask + flask-cors for API server
numpy + scipy for geometric computations
psycopg2 for PostgreSQL
redis for caching
requests for HTTP client
Environment Variables Required
DATABASE_URL: PostgreSQL connection string
INTERNAL_API_KEY: For Python ↔ TypeScript authentication (required in production)
NODE_BACKEND_URL: Optional, defaults to localhost:5000
Saved progress at the end of the loop
Add news search for current topics
3 / 5

61 actions
edited 10 files, took 1 screenshot
The war modes have been renamed to learning-focused flow states. Would you like me to add any additional features or make other changes?

Checkpoint made
Saved progress at the end of the loop
Worked for 10 minutes
all fetures on "/spawning" are wired up correctly and merge and cannibalizm working within the eveolution and e8 structure? debates, lifecycle, spawned kernels and justification? all automated kernel controled.


1 message & 60 actions
Based on my review, **all the spawning features are correctly wired up**: **Merge & Cannibalize (E8 Evolution):** - Auto-merge uses Fisher distance clustering (geometric similarity threshold 0.3) - Auto-cannibalize uses geometric fitness: `Φ_gradient * 0.4 + κ_stability * 0.3 + fisher_diversity * 0.3` - Both are kernel-controlled - no arbitrary time thresholds, pure QIG selection pressure - Routes tested and working: Python returns proper geometric reasoning **Debates System:** - Autonomous Debate Service running in background (12 gods connected) - Auto-polls every 30 seconds, monitors for resolution - Debates resolve when Fisher convergence < 0.1 with 4+ arguments - Vocabulary learning wired to debate outcomes **Lifecycle & Evolution:** - E8 hybrid architecture active (max 240 kernels, 60 active) - Observation protocol: 500 cycles before kernels can act - Hestia/Demeter/Chiron guardian system for new kernels - Graduation system for kernel maturity **Spawned Kernels:** - M8 spawning protocol with PostgreSQL persistence - Every spawn includes geometric justification - Self-spawning kernels observe parents before acting **All Automated:** - No manual intervention needed - Kernels make decisions based on geometric metrics (Φ, κ, Fisher distance) - Evolution runs every 60 seconds automatically
enhance search both shadow and regular with https://pypi.org/project/duckduckgo-search/


3 actions
Integrated AI-Powered Chatbot for QIG Support: An intelligent chatbot accessible within the interface that can answer user questions about QIG concepts, troubleshoot issues, and provide guidance on using the brain wallet tool.


4 actions
installed 1 package
enhance search both shadow and regular with https://pypi.org/project/duckduckgo-search/

I'll create a DuckDuckGo search adapter and integrate it with both the shadow search (Hades) and regular search (Zeus).

Now I'll add DuckDuckGo as a third fallback option in Zeus's regular search. Let me update the imports and the search method:

Now I need to update the search method to use DuckDuckGo as a third fallback. Let me update the handle_search_request method: